<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="robots" content="nofollow"/>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperTime最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF9900}
a.orange:visited {color:#FF9900}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
span.gray:hover {color:#000000}

.red{color:#FF0000}
span.red:hover {color:#000000}
.orange{color:#FF9900}
span.orange:hover {color:#000000}

a{TEXT-DECORATION:none}
a:hover{TEXT-DECORATION:underline;}
.conNum1{padding:0 5px;height:20px;border:1px solid #ccc;}
.paper .autotype3{color:#FF0000;}
.paper .autotype2{color:#FFA500;}
-->
</style>
<script type="text/javascript" src="jquery-1.8.2.min.js"></script>
</head>
<body>
<div class="zhengwen">
		    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>1</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>基于JAVA的Web服务器设计与开发</span><br><span class='green'>摘    要</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>2</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/0.htm' target='right'><span class='orange'>随着互联网技术的发展，Web得到了很好的发展，</span></a><span class='green'>因为其具有平台无关性，通用性，有相当多的应用系统都从c/s模式转变为了b/s模式，</span><a href='../sentence_detail/1.htm' target='right'><span class='orange'>以及开发者们不满足在互联网上获取静态资源，</span></a><span class='green'></span><a href='../sentence_detail/2.htm' target='right'><span class='orange'>网络的发展方向开始朝着向服务器动态获取资源前进；</span></a><span class='green'></span><a href='../sentence_detail/3.htm' target='right'><span class='orange'>同时为了满足高负载和支撑事务，安全，集成，通信等，</span></a><span class='green'></span><a href='../sentence_detail/4.htm' target='right'><span class='orange'>Web服务器为互联网上的应用提供了一个可以实时交互的平台，</span></a><span class='green'></span><a href='../sentence_detail/5.htm' target='right'><span class='orange'>即可以处理静态资源又可以处理动态的Servlet。</span></a><span class='green'></span><a href='../sentence_detail/6.htm' target='right'><span class='orange'>本文简要的描述了web服务器的背景，现状，</span></a><span class='green'>以及发展趋势，并介绍Web服务器所使用到的技术。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>3</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>关键词：web服务器；Java；http协议；Servlet</span><br><span class='green'>JAVA-based Web Server Design and Develop</span><br><span class='green'>ABSTRACT</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>4</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/7.htm' target='right'><span class='red'>With the development of Internet technology,</span></a><span class='green'> the network has developed very well because of its platform independence and versatility. A considerable number of application systems have changed from C / S mode to B / S mode, and the developers are not satisfied. Obtain static resources on the Internet, the development direction of the network began to move towards the server to obtain resources dynamically; at the same time in order to meet the high load and support services,</span><a href='../sentence_detail/8.htm' target='right'><span class='orange'> security, integration, communications, etc.</span></a><span class='green'>, the website server provides a real-time interaction for applications on the Internet.</span><a href='../sentence_detail/9.htm' target='right'><span class='orange'> The platform can handle static resources and can handle dynamic servlets.</span></a><span class='green'> This article briefly describes the background, status quo, and development trends of web servers, and introduces the technologies used by web servers.</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>5</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>KEY WORDS ：Web server; Java; http protocol; Servlet</span><br><span class='green'>目  录</span><br><span class='green'>摘    要	I</span><br><span class='green'>ABSTRACT	II</span><br><span class='green'>引言（前言）	4</span><br><span class='green'>1. 系统背景介绍	5</span><br><span class='green'>1.1 Web服务器的发展现状	5</span><br><span class='green'>1.2 本文的主要工作	5</span><br><span class='green'>2 Web容器的研究	7</span><br><span class='green'>2.1 HTTP协议分析	7</span><br><span class='green'>2.1.1 HTTP协议概述	7</span><br><span class='green'>2.1.2 HTTP协议的发展	7</span><br><span class='green'>2.1.3 HTTP协议的传输过程	8</span><br><span class='green'>2.1.4 HTTP协议的主要内容	10</span><br><span class='green'>2.2 Socket编程	14</span><br><span class='green'>2.2.1 Socket概述	14</span><br><span class='green'>2.2.2 Java Socket编程	15</span><br><span class='green'>2.3 本章小结	16</span><br><span class='green'>3 Web服务器的设计	18</span><br><span class='green'>3.1 总体模块划分	18</span><br><span class='green'>3.2 业务流程	19</span><br><span class='green'>4 Web服务器的实现	22</span><br><span class='green'>4.1 概述	22</span><br><span class='green'>4.2 connector模块	23</span><br><span class='green'>4.2.1 connector模块概述	23</span><br><span class='green'>4.2.2 监听socket请求的实现	23</span><br><span class='green'>4.2.3 解析request请求的实现	25</span><br><span class='green'>4.2.4 编码response响应的实现	27</span><br><span class='green'>4.3 container模块	28</span><br><span class='green'>4.3.1 container模块概述	28</span><br><span class='green'>4.3.2 功能链	28</span><br><span class='green'>4.3.3 URL映射	29</span><br><span class='green'>4.4 parse模块	30</span><br><span class='green'>结论	33</span><br><span class='green'>参考文献	34</span><br><span class='green'>致谢	35</span><br><span class='green'>引言（前言）</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>6</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>随着web应用的兴起和移动设备的快速增长，互联网迎来了爆炸式的发展，这也让web系统承载了巨大的压力，但这也推动了web的发展，</span><a href='../sentence_detail/10.htm' target='right'><span class='orange'>使得web技术得到了很好的发展，</span></a><span class='green'>如今web已经成为了Internet最主要的信息传送媒介，而web的发展同时也带动了web服务器的发展以适应日益增多的访问量以及各种需求。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>7</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>Web服务器主要解决的是各种平台的计算机之间的信息交互。它主要采用的是传输层的TCP/IP协议来交换报文，</span><a href='../sentence_detail/11.htm' target='right'><span class='orange'>http协议是位于传输层之上的应用层，</span></a><span class='green'>http协议的内容就存放在TCP/IP协议中的报文中，本课题要研究的主要问题就是解析HTTP协议，正确加载静态与动态内容。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>8</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>1.	系统背景介绍</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>9</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>Web服务器就是可以为我们提供Web服务的主机，常用的web服务是http，</span><a href='../sentence_detail/12.htm' target='right'><span class='orange'>我们在浏览器中键入URL地址，</span></a><span class='green'></span><a href='../sentence_detail/13.htm' target='right'><span class='orange'>相对应的web服务器接收到一个HTTP请求，解析请求，并返回一个HTTP响应，</span></a><span class='green'>返回的内容经过JavaScript的处理，以人类可读的方式显示在浏览器页面中。本课题做的就是做一个基于HTTP协议的实现Servlet规范的轻量级Web服务器。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>10</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/14.htm' target='right'><span class='red'>项目采用Java语言进行开发。</span></a><span class='green'></span><a href='../sentence_detail/15.htm' target='right'><span class='red'>Java语言从一开始就支持网络编程，</span></a><span class='green'></span><a href='../sentence_detail/16.htm' target='right'><span class='red'>并提供了大量类和接口可以用来处理各种网络协议，共享信息，并行计算，</span></a><span class='green'></span><a href='../sentence_detail/17.htm' target='right'><span class='orange'>并且Java提供了完全意义的多线程支持，</span></a><span class='green'></span><a href='../sentence_detail/18.htm' target='right'><span class='orange'>这些特点使得使用Java成为开发Web服务器的首选计算机语言，</span></a><span class='green'>目前基于Java语言开发商用的Web服务器已经有一些了，</span><a href='../sentence_detail/19.htm' target='right'><span class='orange'>如WebLogic，Tomcat等。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>11</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>1.1	Web服务器的发展现状</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>12</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>随着互联网的快速发展，Web服务器也随之一起在数量和种类上得到了飞速发展，现如今，</span><a href='../sentence_detail/20.htm' target='right'><span class='orange'>Web服务器主要分为WWW服务器，</span></a><span class='green'>FTP服务器，邮件服务器，数据库服务器，代理服务器，域名服务器等等......在本文当中，</span><a href='../sentence_detail/21.htm' target='right'><span class='orange'>我们主要介绍的是基于Java的Web容器，</span></a><span class='green'>既能实现对静态资源的访问，当然主要是实现servlet规范从而可以实现响应动态内容。虽然Web容器可以单独运行，</span><a href='../sentence_detail/22.htm' target='right'><span class='orange'>但是一般都是将其与apache等HTTP服务器一起搭配使用，</span></a><span class='green'>因为apache等HTTP服务器加载静态内容的速度更加的快 ，由apache服务器来处理静态资源，而将动态响应交给Web容器来处理。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>13</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>1.2	本文的主要工作</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>14</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>从前文得知，当前有许多种类型的Web容器，Web服务器，</span><a href='../sentence_detail/23.htm' target='right'><span class='orange'>它们适合运行在不同的操作系统，</span></a><span class='green'>不同的Web服务器以及不同的Web容器上，如C＃开发的服务器端后台一般都是部署在Windows Server操作系统的IIS Web服务器上，当然现在微软出了.</span><a href='../sentence_detail/24.htm' target='right'><span class='orange'>NET Core后，C＃开发的服务器端程序也可以部署在Linux上面了，</span></a><span class='green'>而Java开发的服务器端程序主要部署在Linux上的apache服务器与tomcat容器中。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>15</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>本文主要是设计一个基于Java的Web服务器，实现这个服务器是为了给上层的应用系统提供一个合适便利的开发平台。因为涉及到在此平台上进行上层的应用开发，所以将其称之为上层应用开发。因此，</span><a href='../sentence_detail/25.htm' target='right'><span class='orange'>本Web服务器需要解决四个问题：</span></a><span class='green'></span><a href='../sentence_detail/26.htm' target='right'><span class='orange'>①将TCP协议的报文解析成HTTP协议的内容，</span></a><span class='green'>上层应用不需要再面对解析HTTP协议②上层应用不需要考虑对网络输入输出进行编程，只需要对业务进行编程即好③线程调度问题，上层应用不需要管理多线程，交由此Web服务器来管理多线程④URL映射问题，由web容器来决定此URL交由上层应用的哪个方法运行。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>16</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>2	Web容器的研究</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>17</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>Web服务器，其实就是能够给人们提供HTTP服务的主机，当用户通过在浏览器上键入该Web服务器的主机地址或者ip地址来访问该Web服务器上的各种所需资源。那么究竟什么是Web呢？</span><a href='../sentence_detail/27.htm' target='right'><span class='red'>WEB你可以这样简单理解为你所看到的HTML页面就是WEB的数据元素,处理这些数据元素的应用软件就叫WEB服务器,如IIS、apache。</span></a><span class='green'></span><a href='../sentence_detail/28.htm' target='right'><span class='red'> WEB服务器与客户端打交道，它主要处理的信息有：session、request、response、HTML、JavaScript、CSS等。</span></a><span class='green'>而Web容器如tomcat，</span><a href='../sentence_detail/29.htm' target='right'><span class='red'>处理的是非常规性WEB页面（JSP文件），他动态生成WEB页面，</span></a><span class='green'>生成的WEB页面再发送给客户端。</span><a href='../sentence_detail/30.htm' target='right'><span class='red'>Web服务器一般是普遍通用的，而Web容器一般是专用的，如Tomcat只能处理JAVA应用程序而不能处理ASPX或PHP。</span></a><span class='green'></span><a href='../sentence_detail/31.htm' target='right'><span class='red'>而Apache是一个Web服务器（HTTP服务器），后来连接Tomcat应用服务器来支持java。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>18</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>2.1	HTTP协议分析</span><br><span class='green'>2.1.1	HTTP协议概述</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>19</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/32.htm' target='right'><span class='red'>超文本传输协议（Hypertext Transfer Protocol，简称HTTP）是应用层协议，它是基于TCP/IP通信协议来传递数据的，自 1990 年起，HTTP 就已经被应用于 WWW 全球信息服务系统。</span></a><span class='green'></span><a href='../sentence_detail/33.htm' target='right'><span class='red'>HTTP 是一种请求/响应式的协议。</span></a><span class='green'></span><a href='../sentence_detail/34.htm' target='right'><span class='red'>一个客户机与服务器成功建立连接后，发送一个请求给服务器；然后等服务器接到请求后，给予相应的响应信息。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>20</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>2.1.2	HTTP协议的发展</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>21</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/35.htm' target='right'><span class='red'>HTTP 的第一版本 HTTP/0.9是一种比较简单的用于网络间原始数据传输的协议,</span></a><span class='green'></span><a href='../sentence_detail/36.htm' target='right'><span class='red'>功能确实极其简单，不涉及数据包的传输，默认使用80端口，只有一个GET请求方法，且服务器只能响应HTML格式的字符串，服务器响应后即关闭连接。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>22</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/37.htm' target='right'><span class='red'>HTTP/1.0由 RFC 1945 定义 ，在原 HTTP/0.9 的基础上，</span></a><span class='green'></span><a href='../sentence_detail/38.htm' target='right'><span class='red'>引入了POST和HEAD命令，大大增强了网络交互功能，可以发送任何格式的内容，为互联网的大发展而奠定了基础；同时，除去数据部分，每次通信还要求包含头信息（HTTP header），来描述一些meta数据。</span></a><span class='green'></span><a href='../sentence_detail/39.htm' target='right'><span class='red'>新增功能还包括：状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</span></a><span class='green'></span><a href='../sentence_detail/40.htm' target='right'><span class='red'> HTTP/1.0版的主要缺点有，由于TCP的每次连接都需要客户端和服务端进行3次握手，但是连接成功后却只能发送一次请求，而后连接就断开了，假如需要多次请求，这样效率就很低。</span></a><span class='green'></span><a href='../sentence_detail/41.htm' target='right'><span class='red'>所以，为了解决多次请求效率低下的问题，有一个非标准的connection字段算是暂时解决了这个问题。</span></a><span class='green'></span><a href='../sentence_detail/42.htm' target='right'><span class='red'>Connection: keep-alive。</span></a><span class='green'></span><a href='../sentence_detail/43.htm' target='right'><span class='red'>这样我们可以复用TCP连接，直到客户端或者服务端主动关闭了连接。</span></a><span class='green'></span><a href='../sentence_detail/44.htm' target='right'><span class='red'>不过这不是标志字段，不同的实现可能行为不一致，所以是一种暂时的解决方案。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>23</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/45.htm' target='right'><span class='orange'>HTTP/1.1进一步完善了HTTP协议，一直到现在还在使用，是最受欢迎的版本。</span></a><span class='green'></span><a href='../sentence_detail/46.htm' target='right'><span class='red'>HTTP/1.1新增了许多特性。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>24</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>1）	持久连接</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>25</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/47.htm' target='right'><span class='red'>HTTP/1.1默认TCP连接不关闭，能够被多个请求复用，不用声明Connection: keep-alive。</span></a><span class='green'></span><a href='../sentence_detail/48.htm' target='right'><span class='red'>在最后一个请求时，客户端可以主动发送Connection: close，明确要求服务器关闭TCP连接，或者选择不发送，那么客户端和服务器发现对方一段时间没有活动，就会主动关闭连接。</span></a><span class='green'></span><a href='../sentence_detail/49.htm' target='right'><span class='red'>目前，针对同一个域名，大多数浏览器允许同时建立6个持久连接。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>26</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>2）	管道机制</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>27</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/50.htm' target='right'><span class='red'>HTTP/1.1引入了管道机制（pipelining），即在同一个TCP连接里面，客户端能够同时发送多个请求，这样只不过改进了客户端HTTP协议请求的效率，服务器依然按照请求的先后顺序来响应。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>28</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>3）	Content-Length</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>29</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/51.htm' target='right'><span class='red'>Content-Length字段显示本次响应的数据长度，如果数据被压缩，则是显示压缩后的长度。</span></a><span class='green'></span><a href='../sentence_detail/52.htm' target='right'><span class='red'>在Connection: keep-alive条件下，Content-Length是必须要有的；反之，和HTTP/1.0一样，Content-Length不是必须的。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>30</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>4）	分块传输编码</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>31</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/53.htm' target='right'><span class='red'>使用Content-Lenght字段有一个前提条件，就是在服务器发送响应之前，必须要知道响应的数据长度。</span></a><span class='green'></span><a href='../sentence_detail/54.htm' target='right'><span class='red'>但是，对于一些耗时的动态操作来说，等到所有操作完成了，服务器才能发送数据，效率是不高的。</span></a><span class='green'></span><a href='../sentence_detail/55.htm' target='right'><span class='red'>因此，HTTP采用了“流模式（stream）”，即“分块传输编码”（chunked transfer encoding）方式，表明响应的数据长度不确定，这样就可以每产生一块数据，就发送一块数据，从而提高服务器的响应效率。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>32</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>5）	Transfer-Encoding: chunked</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>33</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/56.htm' target='right'><span class='red'>这样，只要请求或响应的头部信息里有Transfer-Encoding字段，就表明响应是由数量未定的数据来组成。</span></a><span class='green'></span><a href='../sentence_detail/57.htm' target='right'><span class='red'>每个非空的数据块前面，都会有一个16进制的数值，来表示这个块的长度；最后一个是大小为0的块，表示本次响应数据已发送完了。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>34</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>2.1.3	HTTP协议的传输过程</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>35</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/58.htm' target='right'><span class='orange'>HTTP协议是位于OSI网络模型中的应用层，</span></a><span class='green'></span><a href='../sentence_detail/59.htm' target='right'><span class='orange'>它是基于TCP/IP协议作为底层传输的。</span></a><span class='green'>客户端的浏览器先是发起socket套接字的请求与服务器建立连接，等TCP三次握手成功后，客户端与服务器就连接建立，客户端将HTTP协议的内容封装在TCP协议中的报文，由TCP协议来发送给HTTP请求消息，这时客户端也从自己的TCP中的报文中接受到HTTP响应。等到客户端或者服务器将HTTP协议的内容发送给TCP之后，HTTP协议就不去管这个内容是怎样去传输的，</span><a href='../sentence_detail/60.htm' target='right'><span class='orange'>TCP提供了一个可靠的端到端的数据传输服务，</span></a><span class='green'>这就说明了每一个由客户端发出去的HTTP协议的内容都能以相同的顺序到达服务器端，且是无损的到达。这就是OSI网络模型中的解耦合，HTTP协议只需要密切关注本协议是如何运行的，</span><a href='../sentence_detail/61.htm' target='right'><span class='orange'>无须担心数据会丢失，也不必担心TCP如何将数据从错误的顺序，以及错误的数据中恢复出来，</span></a><span class='green'>这些已经是位于应用层以下的协议要去处理的任务了。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>36</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>下面分析具体的HTTP消息传输过程。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>37</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>图 2 1 HTTP消息传输过程</span><br><span class='green'>1）	建立TCP连接</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>38</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>TCP连接在计算机中是通过socket来封装的，</span><a href='../sentence_detail/62.htm' target='right'><span class='orange'>建立socket连接要提供一个ip地址和目的主机的端口号，</span></a><span class='green'></span><a href='../sentence_detail/63.htm' target='right'><span class='orange'>直到通过三次握手成功建立连接后，</span></a><span class='green'></span><a href='../sentence_detail/64.htm' target='right'><span class='orange'>就可以开始在客户端和服务器端进行数据传输了。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>39</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>2）	HTTP请求消息</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>40</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/65.htm' target='right'><span class='orange'>客户端将HTTP协议的内容封装交给socket来发送，</span></a><span class='green'>其本质是将HTTP协议的内容封装到TCP协议报文中然后发送。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>41</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>3）	HTTP响应消息</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>42</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/66.htm' target='right'><span class='orange'>服务器端从socket中接受到HTTP协议的内容，经过解析后，</span></a><span class='green'>按照请求内容发送相对应的响应消息。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>43</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>4）	释放TCP连接</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>44</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/67.htm' target='right'><span class='orange'>客户端和服务器端双方都可以通过关闭socket来释放TCP连接，在HTTP/1.0中，当服务器端发送完客户端请求的文件后会主动的关闭socket连接，</span></a><span class='green'></span><a href='../sentence_detail/68.htm' target='right'><span class='orange'>而在HTTP/1.1中，一般是保持长连接的，</span></a><span class='green'>并不关闭socket连接。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>45</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>2.1.4	HTTP协议的主要内容</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>46</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>HTTP协议的主要内容是关于HTTP请求和响应的文本，请求的文本是客户端要求服务器端提供的服务的信息，</span><a href='../sentence_detail/69.htm' target='right'><span class='orange'>响应的文本则是服务器端接收到请求后返回给客户端的消息。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>47</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>1）	客户端请求格式</span><br><span class='green'>a）	请求的消息格式</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>48</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/70.htm' target='right'><span class='red'>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）请求头部（header）、空行和请求数据四个部分组成。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>49</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>图 2 2 请求消息格式</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>50</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/71.htm' target='right'><span class='orange'>Get请求例子，使用Postman code模式看到的request请求的文本：</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>51</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>表 2 1 Get请求例子</span><br><span class='green'>GET http://download.microtool.de:80/somedata.exe</span><br><span class='green'>Host: download.microtool.de</span><br><span class='green'>Accept:*/*</span><br><span class='green'>Pragma: no-cache</span><br><span class='green'>Cache-Control: no-cache</span><br><span class='green'>Referer: http://download.microtool.de/</span><br><span class='green'>User-Agent:Mozilla/4.04[en]（Win95;I;Nav）</span><br><span class='green'>Range:bytes=554554-</span><br><span class='green'>Postman-Token: 26d138d4-6123-479e-0bb9-15d37a936dcd</span><br><span class='green'>b）	请求方法</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>52</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>方法描述了对于资源所要做的操作。</span><a href='../sentence_detail/72.htm' target='right'><span class='orange'>在HTTP/1.1中的请求的方法有:OPTIONS,GET,HEAD,PUT,POST,TRACE,DELETE，</span></a><span class='green'></span><a href='../sentence_detail/73.htm' target='right'><span class='orange'>其中最常用的是GET,POST,PUT,DELETE，在RESTFUL规范中，</span></a><span class='green'>RESTFUL是以资源为导向设计API的，</span><a href='../sentence_detail/74.htm' target='right'><span class='orange'>GET表示获取资源，POST表示添加资源，PUT表示修改资源，DELETE表示删除资源。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>53</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>图 2 3 HTTP请求方法</span><br><span class='green'>c）	头部字段</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>54</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/75.htm' target='right'><span class='orange'>头部字段分为通用请求头，请求头和响应头，</span></a><span class='green'></span><a href='../sentence_detail/76.htm' target='right'><span class='orange'>通用请求头就是既能用于请求，也能用于响应，是作为一个整体而不是与事务相关联的特定资源，</span></a><span class='green'>并且请求头和响应头就是只有在请求和响应时可以带上。</span><a href='../sentence_detail/77.htm' target='right'><span class='red'>请求头允许客户端传递关于自身的信息和所希望的响应形式，</span></a><span class='green'></span><a href='../sentence_detail/78.htm' target='right'><span class='red'>响应头用来表示服务器和于传递自身信息的响应。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>55</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>常用的请求头如下表所示：</span><br><span class='green'>表 2 2 常用的请求头</span><br><span class='green'>Header	解释	示例</span><br><span class='green'>Accept	指定客户端能够接收的内容类型	Accept: text/plain, text/html</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>56</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/79.htm' target='right'><span class='orange'>Accept-Charset	浏览器可以接受的字符编码集。</span></a><span class='green'></span><a href='../sentence_detail/80.htm' target='right'><span class='red'>	Accept-Charset: iso-8859-5</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>57</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/81.htm' target='right'><span class='red'>Accept-Encoding	指定浏览器可以支持的web服务器返回内容压缩编码类型。</span></a><span class='green'></span><a href='../sentence_detail/82.htm' target='right'><span class='red'>	Accept-Encoding: compress, gzip</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>58</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>Accept-Language	浏览器可接受的语言	Accept-Language: en,zh</span><br><span class='green'>Cookie	HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。	Cookie: $Version=1; Skin=new;</span><br><span class='green'>Content-Type	请求的与实体对应的MIME信息	Content-Type: application/x-www-form-urlencoded</span><br><span class='green'>Host	指定请求的服务器的域名和端口号	Host: www.zcmhi.com</span><br><span class='green'>1）	服务器端响应</span><br><span class='green'>a）	响应的消息格式</span><br><span class='green'>图 2 4 响应消息格式</span><br><span class='green'>服务器端响应例子：</span><br><span class='green'>表 2 3 服务器端响应例子</span><br><span class='green'>HTTP/1.1 200 OK</span><br><span class='green'>Date: Mon, 27 Jul 2009 12:28:53 GMT</span><br><span class='green'>Server: Apache01</span><br><span class='green'>Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT</span><br><span class='green'>ETag: “34aa387-d-1568eb00“</span><br><span class='green'>Accept-Ranges: bytes</span><br><span class='green'>Content-Length: 51</span><br><span class='green'>Vary: Accept-Encoding</span><br><span class='green'>Content-Type: text/plain</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>59</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/83.htm' target='right'><span class='red'>Hello World! My payload includes a trailing CRLF.</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>60</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>b）	响应头</span><br><span class='green'>常用的响应头如下表所示：</span><br><span class='green'>表 2 4 常用的响应头</span><br><span class='green'>Header	解释	示例</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>61</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/84.htm' target='right'><span class='red'>Content-Encoding	web服务器支持的返回内容压缩编码类型。</span></a><span class='green'></span><a href='../sentence_detail/85.htm' target='right'><span class='red'>	Content-Encoding: gzip</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>62</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>Content-Language	响应体的语言	Content-Language: en,zh</span><br><span class='green'>Content-Length	响应体的长度	Content-Length: 348</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>63</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/86.htm' target='right'><span class='red'>Content-Location	请求资源可替代的备用的另一地址	Content-Location: /index.htm</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>64</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>Content-Type	返回内容的MIME类型	Content-Type: text/html; charset=utf-8</span><br><span class='green'>Last-Modified	请求资源的最后修改时间	Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</span><br><span class='green'>Server	web服务器软件名称	Server: Apache/1.3.27 （Unix） （Red-Hat/Linux）</span><br><span class='green'>Set-Cookie	设置Http Cookie	Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</span><br><span class='green'>2.2	Socket编程</span><br><span class='green'>2.2.1	Socket概述</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>65</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/87.htm' target='right'><span class='orange'>要了解socket，首先需要知道socket是对TCP/IP的封装，</span></a><span class='green'>那么什么是TCP哪。</span><a href='../sentence_detail/88.htm' target='right'><span class='red'>TCP是Tranfer Control Protocol的 简称，是一种面向连接的保证可靠传输的协议。</span></a><span class='green'></span><a href='../sentence_detail/89.htm' target='right'><span class='red'>通过TCP协议传输，得到的是一个顺序的无差错的数据流。</span></a><span class='green'></span><a href='../sentence_detail/90.htm' target='right'><span class='red'>发送方和接收方的成对的两个socket之间必须建 立连接，以便在TCP协议的基础上进行通信，当一个socket（通常都是server socket）等待建立连接时，另一个socket可以要求进行连接，一旦这两个socket连接起来，它们就可以进行双向数据传输，双方都可以进行发送 或接收操作。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>66</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>2.2.2	Java Socket编程</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>67</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>Socket编程分为服务器端socket编程和客户端socket编程。</span><a href='../sentence_detail/91.htm' target='right'><span class='orange'>下面分别介绍两种socket编程的步骤。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>68</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>1）	服务器端socket编程</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>69</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>a）	服务器端的socket首先需要绑定在本地的某个IP和端口上。在Java中默认为0.0.0.0，</span><a href='../sentence_detail/92.htm' target='right'><span class='orange'>在服务器中0.0.0.0表示本机上所有的IPv4地址，因为服务器可能会有多个IP地址，</span></a><span class='green'>比如绑定在127.0.0.1就表示这个Socket只能接受局域网内的socket连接。具体代码如下,表示绑定在本机IP为0.0.0.0的80端口上，80也是HTTP的默认端口号。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>70</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>表 2 5 服务器端绑定端口</span><br><span class='green'>ServerSocket serverSocket=new ServerSocket（80）</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>71</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/93.htm' target='right'><span class='orange'>b）	将socket设置到监听模式等待客户端连接。</span></a><span class='green'>这个accept（）方法是阻塞的，当有连接建立时，将返回一个socket用来和客户端进行交互。代码如下：</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>72</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>表 2 6 等待连接</span><br><span class='green'>socket=serverSocket.accept（）</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>73</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>c）	使用连接建立后返回的socket与客户端进行通信。</span><a href='../sentence_detail/94.htm' target='right'><span class='orange'>TCP是可以进行全双工通信的，</span></a><span class='green'>所以通过socket变量，</span><a href='../sentence_detail/95.htm' target='right'><span class='orange'>我们可以拿到输入流和输出流，</span></a><span class='green'>输入流就是客户端发送给服务器端的信息，</span><a href='../sentence_detail/96.htm' target='right'><span class='orange'>输出流就是服务器端想要返回给客户端的信息。</span></a><span class='green'>代码如下:</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>74</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>表 2 7 socket读写</span><br><span class='green'>InputStream is=socket.getInputStream（）;</span><br><span class='green'>BufferedInputstream bis=new BufferedInputstream（is）;</span><br><span class='green'>String content=bis.readLine（）;</span><br><span class='green'>OutputStream os=socket.getOutpuStream（）;</span><br><span class='green'>BufferedOutputStream bos=new BufferedOutputStream（os）;</span><br><span class='green'>String outputContent=”hello world”;</span><br><span class='green'>bos.write（bos） ;</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>75</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>d）	关闭连接。</span><a href='../sentence_detail/97.htm' target='right'><span class='orange'>当客户端和服务器端的通信结束之后，</span></a><span class='green'>需要释放连接。因为我们将socket的输入流和输出流用缓冲流包装了，</span><a href='../sentence_detail/98.htm' target='right'><span class='orange'>所以关闭包装后的输入流和输出流也就是关闭socket自身的输入流和输出流，</span></a><span class='green'></span><a href='../sentence_detail/99.htm' target='right'><span class='orange'>最后再关闭socket自身。</span></a><span class='green'>代码如下:</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>76</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>表 2 8 关闭socket</span><br><span class='green'>bis.close（）;</span><br><span class='green'>bos.close（）;</span><br><span class='green'>socket.close（）</span><br><span class='green'>2）	客户端socket编程</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>77</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/100.htm' target='right'><span class='orange'>a）	客户端首先需要新建Socket，</span></a><span class='green'></span><a href='../sentence_detail/101.htm' target='right'><span class='orange'>并输入需要连接的服务器的IP地址和需要访问的端口号，</span></a><span class='green'>下图表示与IP为1.1.1.1的主机在80端口号上建立连接。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>78</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>表 2 9 新建socket连接</span><br><span class='green'>Socket socket = new Socket（‘1.1.1.1’,80）</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>79</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>b）	使用连接建立后的socket与服务器端进行通信。</span><a href='../sentence_detail/102.htm' target='right'><span class='orange'>Java的socket是自动进行连接的，</span></a><span class='green'>不需要函数调用。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>80</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>表 2 10 socket读写</span><br><span class='green'>InputStream is=socket.getInputStream（）;</span><br><span class='green'>BufferedInputstream bis=new BufferedInputstream（is）;</span><br><span class='green'>String content=bis.readLine（）;</span><br><span class='green'>OutputStream os=socket.getOutpuStream（）;</span><br><span class='green'>BufferedOutputStream bos=new BufferedOutputStream（os）;</span><br><span class='green'>String outputContent=”hello world”;</span><br><span class='green'>bos.write（bos） ;</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>81</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>c）	关闭连接。</span><a href='../sentence_detail/103.htm' target='right'><span class='orange'>当客户端和服务器端的通信结束之后，</span></a><span class='green'>需要释放连接。因为我们将socket的输入流和输出流用缓冲流包装了，</span><a href='../sentence_detail/104.htm' target='right'><span class='orange'>所以关闭包装后的输入流和输出流也就是关闭socket自身的输入流和输出流，</span></a><span class='green'></span><a href='../sentence_detail/105.htm' target='right'><span class='orange'>最后再关闭socket自身。</span></a><span class='green'>代码如下:</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>82</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>表 2 11 关闭socket</span><br><span class='green'>bis.close（）;</span><br><span class='green'>bos.close（）;</span><br><span class='green'>socket.close（）</span><br><span class='green'>2.3	本章小结</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>83</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>Web使用的主要是HTTP协议，在这一章中对HTTP进行了详尽的介绍，</span><a href='../sentence_detail/106.htm' target='right'><span class='orange'>包括HTTP的请求格式，响应格式，</span></a><span class='green'>请求方法，请求头以及传输过程等。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>84</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>本章之后介绍了Java下的Socket编程，服务器socket编程和客户端socket编程并没有太多区别，唯一的区别是服务器端最初需要一个ServerSocket来监听在绑定的IP和端口下有没有新新连接，当获得返回的socket后与客户端的编程就并无区别了。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>85</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>3	Web服务器的设计</span><br><span class='green'>3.1	总体模块划分</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>86</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/107.htm' target='right'><span class='orange'>将整个服务器分为几个模块来分别编写，各个模块负责不同的功能，</span></a><span class='green'>模块通过接口来调用其他模块，</span><a href='../sentence_detail/108.htm' target='right'><span class='orange'>实现了解耦合。总体模块结构如图所示。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>87</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>图 3 1 总体模块划分</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>88</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/109.htm' target='right'><span class='orange'>下面将分别简单的介绍各个模块的功能。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>89</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>1）	Socket连接调度模块：Socket连接调度模块是提供对Socket的接受连接以及将socket封装在一个任务中将其交给线程池来处理。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>90</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>2）	HTTP解析模块：</span><a href='../sentence_detail/110.htm' target='right'><span class='orange'>HTTP解析模块中可以分为两个子模块，</span></a><span class='green'>分别是对HTTP请求解码模块以及对HTTP响应编码模块，如下图所示。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>91</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>图 3 2 HTTP解析模块划分</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>92</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>3）	请求响应模块：请求响应模块主要处理的是socket的输入输出，以及数据的缓存.</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>93</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>4）	Servlet调度模块：当获得解析的URL时候，由Servlet调度模块来决定应该使用哪个Servlet进行响应.</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>94</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>5）	Filter调度模块：当获得解析的URL时候，由Filter调度模块来决定使用哪些个Filter来进行过滤</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>95</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>6）	配置解析加载模块：Web服务器是采用外置xml文件来设置参数，如项目需要绑定的端口，</span><a href='../sentence_detail/111.htm' target='right'><span class='orange'>Servlet需要映射的URL，</span></a><span class='green'>打印日志的级别，项目的名称等。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>96</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>3.2	业务流程</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>97</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>下面我将详细的介绍Web服务器的运行流程。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>98</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>1）	当Web服务器启动的时候首先加载xml配置文件进行配置</span><br><span class='green'>2）	创建服务器套接字，并绑定端口，然后监听这个端口</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>99</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/112.htm' target='right'><span class='orange'>3）	Connector连接器负责接受接受客户端连接，</span></a><span class='green'>初始化一个任务交给线程池，任务中包含解析HTTP请求，并构造请求和响应对象以供后续对象调用</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>100</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>4）	将请求和响应对象交给container来调用，</span><a href='../sentence_detail/113.htm' target='right'><span class='orange'>container检索请求对象的URL是否是servlet，若是，</span></a><span class='green'>则加载servlet到内存中，</span><a href='../sentence_detail/114.htm' target='right'><span class='orange'>执行该servlet相关方法，</span></a><span class='green'>若不是，则加载相对应静态文件，若没有相对应的静态文件，则加载一个错误页面内容到响应对象中</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>101</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>5）	将响应对象中的内容写入socket中</span><br><span class='green'>6）	清除HTTP请求和响应对象</span><br><span class='green'>7）	断开socket连接，一次请求结束</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>102</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/115.htm' target='right'><span class='orange'>这就是Web服务器运行的详细流程，</span></a><span class='green'></span><a href='../sentence_detail/116.htm' target='right'><span class='orange'>同时我也画了具体的流程图如下所示。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>103</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>图 3 3 Web服务器流程</span><br><span class='green'>4	Web服务器的实现</span><br><span class='green'>4.1	概述</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>104</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/117.htm' target='right'><span class='orange'>本Web服务器是面向接口编程的，</span></a><span class='green'>这样当有一个类B需要用到类A的时候，就不用需要A的实现类，只需要持有A的接口即可，不必关心实现类具体是哪个，达到了类之间的解耦合。为这个Web服务器，我设计了如下16个接口。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>105</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>下面我将分别介绍这16个接口的用途。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>106</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>1）	Chain,Valve,ValveSupport接口：这三个接口放在一起讲，是因为它们用来配合完成同一件事情。设计这三个接口中使用了责任链设计模式。Valve接口是用来定义一个在每次调用servlet方法前的方法，Chain接口是功能链，通过Chain将所有的Valve串联在一起，ValveSupport是一个支撑类，用来给Chain提供帮助。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>107</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/118.htm' target='right'><span class='red'>2）	Connector接口：</span></a><span class='green'>connector接口主要完成的接受socket请求，然后转交给container进行处理。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>108</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/119.htm' target='right'><span class='orange'>3）	Contained接口：</span></a><span class='green'>contained接口用来指示实现它的接口持有哪个container容器的变量。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>109</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>4）	Container接口：container接口的实现类有ContextContainer和ServletContainer分别表示Web容器上下文以及单个servlet的容器。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>110</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>5）	ContextContainer接口：</span><a href='../sentence_detail/120.htm' target='right'><span class='orange'>ContextContainer接口继承了Container接口，</span></a><span class='green'>表示的是此Web容器的上下文。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>111</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/121.htm' target='right'><span class='orange'>6）	HttpRequest，HttpResponse接口：这两个接口分别是HTTP请求和响应的接口，</span></a><span class='green'>同时也继承了servlet规范的request,response接口</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>112</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>7）	LifeCycleListener,LifeCycleSubject接口：这两个接口的设计使用了观察者模式，主要作用是实现模块间的关联启动。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>113</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>8）	Loader接口：Loader接口主要是实现安全加载servlet到容器中。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>114</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>9）	Mapper接口：Mapper接口的主要功能是实现URL到servletClass的映射。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>115</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>10）	Request，Response接口：这两个接口继承了servlet规范中的request,response接口，是这个Web容器中请求和响应的基类接口。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>116</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>4.2	connector模块</span><br><span class='green'>4.2.1	connector模块概述</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>117</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/122.htm' target='right'><span class='orange'>此模块中的HttpRequestImpl,</span></a><span class='green'></span><a href='../sentence_detail/123.htm' target='right'><span class='orange'>HttpResponseImpl都是请求和响应接口的具体实现，</span></a><span class='green'>RequestStream,ResponseStream都是对socket的输入和输出流的缓冲流，同时加上一些功能。下面看这个模块下的所有的类的组成。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>118</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>图 4 1 connector模块中的类</span><br><span class='green'>4.2.2	监听socket请求的实现</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>119</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>JerryConnector这个类是这个包的主类，由它来负责调用其他类。下面请看这个类的主方法，如下表所示</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>120</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>表 4 1 监听socket请求的实现</span><br><span class='green'>public void run（）</span><br><span class='green'>{</span><br><span class='green'>while（start）</span><br><span class='green'>{</span><br><span class='green'>Socket socket=null;</span><br><span class='green'>try {</span><br><span class='green'>socket=serverSocket.accept（）;</span><br><span class='green'>if（timeOut＞0）</span><br><span class='green'>socket.setSoTimeout（timeOut）;</span><br><span class='green'>socket.setTcpNoDelay（true）;</span><br><span class='green'>HttpProcess process=new HttpProcess（socket,container）;</span><br><span class='green'>executorService.submit（process）;</span><br><span class='green'>}</span><br><span class='green'>catch （IOException e） {</span><br><span class='green'>e.printStackTrace（）;</span><br><span class='green'>}</span><br><span class='green'>finally {</span><br><span class='green'>if（socket!=null）</span><br><span class='green'>{</span><br><span class='green'>try {</span><br><span class='green'>socket.close（）;</span><br><span class='green'>}</span><br><span class='green'>catch （IOException e） {</span><br><span class='green'>e.printStackTrace（）;</span><br><span class='green'>}</span><br><span class='green'>}</span><br><span class='green'>}</span><br><span class='green'>}</span><br><span class='green'>if（serverSocket!=null）</span><br><span class='green'>{</span><br><span class='green'>try {</span><br><span class='green'>serverSocket.close（）;</span><br><span class='green'>}</span><br><span class='green'>catch （IOException e） {</span><br><span class='green'>e.printStackTrace（）;</span><br><span class='green'>}</span><br><span class='green'>}</span><br><span class='green'>}</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>121</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>这个方法主要完成的是等待客户端socket的连接，当有连接之后，为这个连接设置一个超时自动关闭连接的时间，将这个socket包装进一个HttpProcess类，然后交给线程池来处理这个HttpProcess类，这样，这个服务器就可以以非阻塞的方式继续运行下去，当同时有多个连接进来时，也不会阻塞。同时，线程池也是一种高效的方式来利用线程，降低了每次创建新线程初始化线程上下文的时间，使得可以同时有更多的连接进来。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>122</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>4.2.3	解析request请求的实现</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>123</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>解析HTTP协议的内容放在HttpProcess中进行的。我们知道，</span><a href='../sentence_detail/124.htm' target='right'><span class='orange'>HTTP的请求中，第一行是请求行，</span></a><span class='green'>第二行开始一直到空白行之前都是请求头，下面总览一下解析request请求代码。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>124</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>表 4 2 解析request请求的总体设计</span><br><span class='green'>void parseRequest（） throws IOException</span><br><span class='green'>{</span><br><span class='green'>parseRequestLine（）;</span><br><span class='green'>parseHeader（）;</span><br><span class='green'>setHeaderAttribute（）;</span><br><span class='green'>}</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>125</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>首先先是解析请求行，然后是解析请求头，最后是将请求行，请求头里解析出来的相关数据赋值到request请求中，以便后续使用，这里注意到我抛出了一个异常，假如请求解析失败则返回一个错误，记录到日志中，解析失败有可能是因为网络问题以及有人发送了错误的HTTP协议的文本请求到服务器。接下来，我们详细看下解析请求行和请求头的代码。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>126</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>我们来看解析请求行的代码</span><br><span class='green'>表 4 3 解析请求行</span><br><span class='green'>void parseRequestLine（） throws IOException</span><br><span class='green'>{</span><br><span class='green'>String str=readLine（）;</span><br><span class='green'>Pattern pattern=patternFactory.getRequestLinePattern（）;</span><br><span class='green'>Matcher matcher= pattern.matcher（str）;</span><br><span class='green'>int condition=0;</span><br><span class='green'>while （matcher.find（））</span><br><span class='green'>{</span><br><span class='green'>String arg= matcher.group（）;</span><br><span class='green'>switch （condition）</span><br><span class='green'>{</span><br><span class='green'>case 0:</span><br><span class='green'>httpRequest.setMethod（arg.toUpperCase（））;</span><br><span class='green'>break;</span><br><span class='green'>case 1:</span><br><span class='green'>if（arg.contains（“?“））</span><br><span class='green'>{</span><br><span class='green'>String queryString=arg.substring（arg.indexOf（‘?‘）+1）;</span><br><span class='green'>queryString=</span><br><span class='green'>URLDecoder.decode（queryString,httpRequest.getCharacterEncoding（））;</span><br><span class='green'>arg=arg.substring（0,arg.indexOf（‘?‘））;</span><br><span class='green'>httpRequest.setQueryString（queryString）;</span><br><span class='green'>Pattern parametersPattern=patternFactory.getParameterPattern（）;</span><br><span class='green'>Matcher parametersMatch= parametersPattern.matcher（queryString）;</span><br><span class='green'>while（parametersMatch.find（））</span><br><span class='green'>{</span><br><span class='green'>String key=parametersMatch.group（1）;</span><br><span class='green'>String value=parametersMatch.group（2）;</span><br><span class='green'>httpRequest.setParameter（key,value）;</span><br><span class='green'>}</span><br><span class='green'>}</span><br><span class='green'>httpRequest.setRequestURI（arg）;</span><br><span class='green'>break;</span><br><span class='green'>case 2:</span><br><span class='green'>httpRequest.setProtocol（arg）;</span><br><span class='green'>break;</span><br><span class='green'>}</span><br><span class='green'>condition++;</span><br><span class='green'>}</span><br><span class='green'>}</span><br><span class='green'>在解析请求行中，因为请求行是一种规范的文本，所以我使用了正则表达式来帮助解析，之后是解析请求头</span><br><span class='green'>表 4 4 解析请求头</span><br><span class='green'>void parseHeader（） throws IOException</span><br><span class='green'>{</span><br><span class='green'>String str=““;</span><br><span class='green'>while （（str=readLine（））!=““）</span><br><span class='green'>{</span><br><span class='green'>//blank line</span><br><span class='green'>if（str==“-1“）</span><br><span class='green'>break;</span><br><span class='green'>Pattern headerPattern=patternFactory.getHeaderPattern（）;</span><br><span class='green'>Matcher headerMatcher=headerPattern.matcher（str）;</span><br><span class='green'>String header,value;</span><br><span class='green'>if（headerMatcher.find（））</span><br><span class='green'>{</span><br><span class='green'>header=headerMatcher.group（1）;</span><br><span class='green'>value=headerMatcher.group（2）;</span><br><span class='green'>httpRequest.setHeader（header,value）;</span><br><span class='green'>if（header.equals（“Cookie“））</span><br><span class='green'>{</span><br><span class='green'>Pattern cookiePattern=patternFactory.getCookiePattern（）;</span><br><span class='green'>Matcher cookieMatcher=cookiePattern.matcher（value）;</span><br><span class='green'>String cookieKey,cookieValue;</span><br><span class='green'>while（cookieMatcher.find（））</span><br><span class='green'>{</span><br><span class='green'>cookieKey=cookieMatcher.group（“name“）;</span><br><span class='green'>cookieValue=cookieMatcher.group（“value“）;</span><br><span class='green'>httpRequest.setCookie（cookieKey,cookieValue）;</span><br><span class='green'>}</span><br><span class='green'>}</span><br><span class='green'>}</span><br><span class='green'>}</span><br><span class='green'>}</span><br><span class='green'>4.2.4	编码response响应的实现</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>127</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>在用户编写的servlet代码里，是不需要关心返回的响应中的那些HTTP状态码，响应头这些的，</span><a href='../sentence_detail/125.htm' target='right'><span class='orange'>这些都是由Web服务器来完成的，</span></a><span class='green'>用户编写的servlet响应的文本是写入到Web服务器的缓存中的，</span><a href='../sentence_detail/126.htm' target='right'><span class='orange'>也即ResponseStream中，</span></a><span class='green'>因为servlet获取到的outputStream早已不是socket的outputStream，</span><a href='../sentence_detail/127.htm' target='right'><span class='orange'>而是被我们替换成ResponseStream了，</span></a><span class='green'>当servlet写入完成调用outputStrean的close方法啊，</span><a href='../sentence_detail/128.htm' target='right'><span class='orange'>或者第一次调用outputStream的flush方法的时候，</span></a><span class='green'>都会触发response的编码，</span><a href='../sentence_detail/129.htm' target='right'><span class='orange'>具体的代码是在ResponseStream里面，</span></a><span class='green'>如下所示</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>128</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>表 4 5 编码response响应</span><br><span class='green'>private void writeHeaders（）</span><br><span class='green'>{</span><br><span class='green'>HttpResponse httpResponse= （HttpResponse） response;</span><br><span class='green'>StringBuilder sb=new StringBuilder（““）;</span><br><span class='green'>int s=httpResponse.getStatus（）;</span><br><span class='green'>HttpStatus  status=HttpStatus.getHttpStatus（s）;</span><br><span class='green'>sb.append（“HTTP/1.1 “+status.getStatus（）+“ “+status.getName（）+“\r\n“）;</span><br><span class='green'>for （String headerName : httpResponse.getHeaderNames（）） {</span><br><span class='green'>String value=httpResponse.getHeader（headerName）;</span><br><span class='green'>sb.append（headerName+“: “+value+“\r\n“）;</span><br><span class='green'>}</span><br><span class='green'>sb.append（“\r\n“）;</span><br><span class='green'>try {</span><br><span class='green'>socketOutputStream.write（sb.toString（）.getBytes（response.getCharacterEncoding（）））;</span><br><span class='green'>}</span><br><span class='green'>catch （IOException e） {</span><br><span class='green'>e.printStackTrace（）;</span><br><span class='green'>}</span><br><span class='green'>}</span><br><span class='green'>4.3	container模块</span><br><span class='green'>4.3.1	container模块概述</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>129</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>如图是container模块中的具体代码。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>130</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>图 4 2 container模块中的类</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>131</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>container模块是Web容器中相当重要的一个模块，</span><a href='../sentence_detail/130.htm' target='right'><span class='orange'>connector模块接受socket后，</span></a><span class='green'>就是直接转交给container模块进行处理的。container模块主要包含四个类，其中ContextContainerImpl是Web容器的上下文，ServletContainerImpl是单个servlet的容器，通过调用它就能对servlet进行操作。ChainImpl是在执行servlet方法前调用的一系列可横向扩展的类，MapperImpl类主要功能是根据配置文件中的URL映射，</span><a href='../sentence_detail/131.htm' target='right'><span class='orange'>依据当前请求的URL来找到进行响应的servlet。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>132</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>4.3.2	功能链</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>133</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>这是我对ChainImpl的中文名称的翻译。</span><a href='../sentence_detail/132.htm' target='right'><span class='orange'>这个类的执行顺序是在执行servlet前，</span></a><span class='green'>对于这个类的设计采用了责任链的设计模式，使得横向添加Valve类不需要改变代码。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>134</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>表 4 6 Valve集合</span><br><span class='green'>private Valve basicValve;</span><br><span class='green'>private ArrayList＜Valve＞ valves=new ArrayList＜＞（）;</span><br><span class='green'>这个类中有一个Valve的集合，Valve接口只有一个invoke方法，如下所示</span><br><span class='green'>表 4 7 Valve接口方法</span><br><span class='green'>void invoke（HttpRequest httpRequest,HttpResponse httpResponse,ValveSupport valveSupport）;</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>135</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>通过这个接口我们就可以对请求和响应接口进行一些修改，或者是在响应前打日志，当然最主要的还是Servlet规范中的Filter接口的执行，Servlet规范中Filter是在Servlet的方法执行前调用的，有了ChainImpl这个类后我们就可以将Filter接口也放在这里执行，同时使用这个Web服务器的人也可以通过自定义Valve类来丰富Web服务器的功能。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>136</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>4.3.3	URL映射</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>137</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>URL映射的过程是这样子的，在配置文件中的写法参考了tomcat的xml配置文件的样式。</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>138</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>表 4 8 XML配置文件范例</span><br><span class='green'>＜servlet＞</span><br><span class='green'>＜servlet-name＞FirstServlet＜/servlet-name＞</span><br><span class='green'>＜servlet-class＞Two＜/servlet-class＞</span><br><span class='green'>＜/servlet＞</span><br><span class='green'>＜servlet-mapping＞</span><br><span class='green'>＜servlet-name＞FirstServlet＜/servlet-name＞</span><br><span class='green'>＜url-pattern＞/*＜/url-pattern＞</span><br><span class='green'>＜/servlet-mapping＞</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>139</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/133.htm' target='right'><span class='orange'>Servlet-class中的参数是实际servlet文件的名称，</span></a><span class='green'>我们在Web容器中为它指定另外一个名称，</span><a href='../sentence_detail/134.htm' target='right'><span class='orange'>这个名称就是servlet-name标签中的名称。</span></a><span class='green'></span><a href='../sentence_detail/135.htm' target='right'><span class='orange'>servlet-mapping标签中包含了两个子标签，其中servlet-name就是容器中指代某个servlet的名称，url-pattern标签的内容表示某个URL.</span></a><span class='green'></span><a href='../sentence_detail/136.htm' target='right'><span class='orange'>那么当我们的服务器在接受到一个请求后，</span></a><span class='green'>它查找servlet的流程是这样的</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>140</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>1）	根据URL查找对应的servlet-name</span><br><span class='green'>2）	若找到相对应的servlet-name则找到相对应的servlet-class</span><br><span class='green'>我们从xml解析出来的映射关系存储在ContextContainerImpl中</span><br><span class='green'>表 4 9 contextContainerImpl中的映射关系</span><br><span class='green'>private HashMap＜String, String＞ patternMap = new HashMap＜＞（）;</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>141</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'>具体查找映射关系是通过Mapper接口的实现类MapperImpl，下面看下具体代码:</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>142</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>表 4 10 查找映射请求关系</span><br><span class='green'>public Container map（HttpRequest request）</span><br><span class='green'>{</span><br><span class='green'>if （request.getServletContainer（） != null） return request.getServletContainer（）;</span><br><span class='green'>String contextPath = request.getContextPath（）;</span><br><span class='green'>String relativeURI = request.getRequestURI（）.substring（contextPath.length（）+1）;</span><br><span class='green'>ServletContainer servletContainer = null;</span><br><span class='green'>String name = null;</span><br><span class='green'>if （servletContainer == null） {</span><br><span class='green'>name = container.findServletContainerMapping（relativeURI）;</span><br><span class='green'>if （name != null） {</span><br><span class='green'>servletContainer = （ServletContainer） container.getChild（name）;</span><br><span class='green'>}</span><br><span class='green'>}</span><br><span class='green'>if （servletContainer == null） {</span><br><span class='green'>while （true） {</span><br><span class='green'>name = container.findServletContainerMapping（relativeURI）;</span><br><span class='green'>if （name != null） {</span><br><span class='green'>servletContainer = （ServletContainer） container.getChild（name）;</span><br><span class='green'>}</span><br><span class='green'>if （servletContainer != null） {</span><br><span class='green'>break;</span><br><span class='green'>}</span><br><span class='green'>int index = relativeURI.lastIndexOf（‘/‘）;</span><br><span class='green'>if （index ＜ 0） break;</span><br><span class='green'>relativeURI = relativeURI.substring（0, index）;</span><br><span class='green'>}</span><br><span class='green'>}</span><br><span class='green'>if （servletContainer == null） {</span><br><span class='green'>relativeURI = request.getRequestURI（）.substring（contextPath.length（）+1）;</span><br><span class='green'>List＜String＞ urlList=URLUtil.splitUrl（relativeURI）;</span><br><span class='green'>urlList.add（“/“）;</span><br><span class='green'>for（int i=0;i＜urlList.size（）;i++）</span><br><span class='green'>{</span><br><span class='green'>name = container.findServletContainerMapping（urlList.get（i））;</span><br><span class='green'>if （name != null） {</span><br><span class='green'>servletContainer = （ServletContainer） container.getChild（name）;</span><br><span class='green'>}</span><br><span class='green'>if （servletContainer != null） {</span><br><span class='green'>break;</span><br><span class='green'>}</span><br><span class='green'>}</span><br><span class='green'>}</span><br><span class='green'>return servletContainer;</span><br><span class='green'>}</span><br><span class='green'>4.4	parse模块</span><br><span class='green'>Parse模块的主要工作是解析xml配置文件，并赋值给相关类，配置文件的格式如下</span><br><span class='green'>表 4 11 xml配置文件范例</span><br><span class='green'>＜?xml version=“1.0“ encoding=“UTF-8“?＞</span><br><span class='green'>＜web-app＞</span><br><span class='green'>＜context name=“jerry“ port=“80“ debug=“info“＞</span><br><span class='green'>＜webroot＞/home/jmt/IdeaProjects/Jerry/webroot/＜/webroot＞</span><br><span class='green'>＜servlet＞</span><br><span class='green'>＜servlet-name＞FirstServlet＜/servlet-name＞</span><br><span class='green'>＜servlet-class＞Two＜/servlet-class＞</span><br><span class='green'>＜/servlet＞</span><br><span class='green'>＜servlet-mapping＞</span><br><span class='green'>＜servlet-name＞FirstServlet＜/servlet-name＞</span><br><span class='green'>＜url-pattern＞/*＜/url-pattern＞</span><br><span class='green'>＜/servlet-mapping＞</span><br><span class='green'>＜/context＞</span><br><span class='green'>＜/web-app＞</span><br><span class='green'>具体的主要解析代码如下</span><br><span class='green'>表 4 12 具体解析代码</span><br><span class='green'>private static ContextBean parseContext（Node contextNode）</span><br><span class='green'>{</span><br><span class='green'>ContextBean contextBean = new ContextBean（）;</span><br><span class='green'>NamedNodeMap attributeMap = contextNode.getAttributes（）;</span><br><span class='green'>Node name = attributeMap.getNamedItem（“name“）;</span><br><span class='green'>contextBean.setName（name.getNodeValue（））;</span><br><span class='green'>Node port = attributeMap.getNamedItem（“port“）;</span><br><span class='green'>contextBean.setPort（Integer.parseInt（port.getNodeValue（）））;</span><br><span class='green'>Node debug = attributeMap.getNamedItem（“debug“）;</span><br><span class='green'>contextBean.setDebug（debug.getNodeValue（））;</span><br><span class='green'>NodeList childList = contextNode.getChildNodes（）;</span><br><span class='green'>for （int i = 0; i ＜ childList.getLength（）; i++） {</span><br><span class='green'>Node node = childList.item（i）;</span><br><span class='green'>if （node.getNodeName（） == “webroot“） {</span><br><span class='green'>contextBean.setWebroot（node.getTextContent（））;</span><br><span class='green'>}</span><br><span class='green'>else if （node.getNodeName（） == “servlet“） {</span><br><span class='green'>NodeList servletNodeList = node.getChildNodes（）;</span><br><span class='green'>String servletName = servletNodeList.item（0）.getTextContent（）;</span><br><span class='green'>String servletClass = servletNodeList.item（1）.getTextContent（）;</span><br><span class='green'>contextBean.setServletNameClass（servletName, servletClass）;</span><br><span class='green'>}</span><br><span class='green'>else if （node.getNodeName（） == “servlet-mapping“） {</span><br><span class='green'>NodeList servletNodeList = node.getChildNodes（）;</span><br><span class='green'>String servletName = servletNodeList.item（0）.getTextContent（）;</span><br><span class='green'>String servletUrl = servletNodeList.item（1）.getTextContent（）;</span><br><span class='green'>contextBean.setServletNameUrl（servletName, servletUrl）;</span><br><span class='green'>}</span><br><span class='green'>}</span><br><span class='green'>return contextBean;</span><br><span class='green'>}</span><br><span class='green'>结论</span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>143</div></td><td>&nbsp;&nbsp;</td></tr></table><span style='margin-left:25px'></span><span class='green'></span><a href='../sentence_detail/137.htm' target='right'><span class='orange'>使用者可以将servlet代码部署在这个Web服务器上，</span></a><span class='green'>服务器可以对静态资源和动态资源进行很好的响应。这个系统最突出的地方就是使用了大量的设计模式使得系统有良好的解耦性和可扩展性，</span><a href='../sentence_detail/138.htm' target='right'><span class='orange'>connector和container是解耦合的，</span></a><span class='green'>我们可以通过更换connector或者container来实现一个更符合业务的Web服务器。也可以自定义Valve来增强这个Web服务器的功能。不足的地方在于这个Web服务器的连接是同步非阻塞的，势必会遇到C10k问题，希望以后可以改成异步非阻塞，</span><a href='../sentence_detail/139.htm' target='right'><span class='orange'>采用Java NIO来重写connector。</span></a><span class='green'></span></p></div></p>
    		<p style="margin:2px"><div><p><table border='0' width='100%' cellspacing='0' cellpadding='0'><tr><td align='left' width='50'><div class='shubu'>144</div></td><td>&nbsp;&nbsp;</td></tr></table><span class='green'>参考文献</span><br><span class='green'>[1]马毅. 轻量级Web服务器的实现与应用[D]. 西北大学, 2008</span><br><span class='green'>[2]宋立昊. 基于线程池的WEB服务器实现和监测[D]. 吉林大学, 2011</span><br><span class='green'>[3]刘穿时. 轻量级web服务器的设计与实现[D]. 华中科技大学, 2016</span><br><span class='green'>[4]柴快长. 轻量级web容器的设计[J]. 科学与财富, 2013（1）:132-132</span><br><span class='green'>[5]Budi Kurniawan, Paul Deck, 曹旭东. 深入剖析Tomcat[M]. 机械工业出版社, 2012</span><br><span class='green'>[6]陈涛, 任海兰. 基于Linux的多线程池并发Web服务器设计[J]. 电子设计工程, 2015（11）:167-169</span><br><span class='green'>[7]兰红, 柳显涛, 李文琼. 基于Linux的预线程化并发Web服务器设计[J]. 江西理工大学学报, 2012, 33（1）:63-67</span><br><span class='green'>[8]上野宣. 图解 HTTP. 于均良译. 北京: 人民邮电出版社, 2014: 2-3</span><br><span class='green'>[9]沙洛韦. 设计模式精解[M]. 清华大学出版社, 2004</span><br><span class='green'>[10]VenkatSubramaniam, 苏帕拉马尼亚姆, 薛笛. Java虚拟机并发编程[M]. 机械工业出版社, 2013</span><br><span class='green'>[11]盖茨, 童云兰. Java并发编程实战[M]. 机械工业出版社, 2012</span><br><span class='green'>[12]杨小娇. 轻量级高并发Web服务器的研究与实现[D]. 南京邮电大学, 2014</span><br><span class='green'>[13]秦浏杰. 高并发Web系统的异步化研究[D]. 华北电力大学, 2015</span><br><span class='green'>[14]web服务器分类及发展趋势的研究[A].2010</span><br><span class='green'>“http://www.itxx.com.cn/Server/webserver/Server_44.html”</span><br><span class='green'>[15]Bielecki M, Hidders J, Paredaens J, et al. The Navigational Power of Web Browsers. Theory of Computing Systems, 2012, 50（2）: 213-240</span><br><span class='green'>[16]Snehi J, Dhir R. Web Client and Web Server approaches to Prevent XSS Attacks[J]. International Journal of Computers ＆ Technology, 2013, 4（2）:345-352</span><br><span class='green'>致谢</span><br><span class='green'>这次毕业论文的顺利完成，要感谢林春梅老师对我的精心指导。这使我能较好的完成这次的项目。如果没有老师的指导，我可能已经完全不知道如何去完成。感谢林春梅老师给我这么一个学习的机会。</span></p></div></p>
    </div>

<div class="zhengwencenter">
</div>
<div style="margin-bottom:50px"></div>

</body>
</html>
