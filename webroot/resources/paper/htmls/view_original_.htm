<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperTime最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>

<div class="zhengwen">


  <br>
<span style="margin-left:25px"></span> 基于JAVA的Web服务器设计与开发
<br>
  <br>
<span style="margin-left:25px"></span> 摘    要
<br>
  <br>
<span style="margin-left:25px"></span> 随着互联网技术的发展，Web得到了很好的发展，因为其具有平台无关性，通用性，有相当多的应用系统都从c/s模式转变为了b/s模式，以及开发者们不满足在互联网上获取静态资源，网络的发展方向开始朝着向服务器动态获取资源前进；同时为了满足高负载和支撑事务，安全，集成，通信等，Web服务器为互联网上的应用提供了一个可以实时交互的平台，即可以处理静态资源又可以处理动态的Servlet。本文简要的描述了web服务器的背景，现状，以及发展趋势，并介绍Web服务器所使用到的技术。
<br>
  <br>
<span style="margin-left:25px"></span> 关键词：web服务器；Java；http协议；Servlet
<br>
  <br>
<span style="margin-left:25px"></span> JAVA-based Web Server Design and Develop
<br>
  <br>
<span style="margin-left:25px"></span> ABSTRACT
<br>
  <br>
<span style="margin-left:25px"></span> With the development of Internet technology, the network has developed very well because of its platform independence and versatility. A considerable number of application systems have changed from C / S mode to B / S mode, and the developers are not satisfied. Obtain static resources on the Internet, the development direction of the network began to move towards the server to obtain resources dynamically; at the same time in order to meet the high load and support services, security, integration, communications, etc., the website server provides a real-time interaction for applications on the Internet. The platform can handle static resources and can handle dynamic servlets. This article briefly describes the background, status quo, and development trends of web servers, and introduces the technologies used by web servers.
<br>
  <br>
<span style="margin-left:25px"></span> KEY WORDS ：Web server; Java; http protocol; Servlet
<br>
  <br>
<span style="margin-left:25px"></span> 目  录
<br>
  <br>
<span style="margin-left:25px"></span> 摘    要	I
<br>
  <br>
<span style="margin-left:25px"></span> ABSTRACT	II
<br>
  <br>
<span style="margin-left:25px"></span> 引言（前言）	4
<br>
  <br>
<span style="margin-left:25px"></span> 1. 系统背景介绍	5
<br>
  <br>
<span style="margin-left:25px"></span> 1.1 Web服务器的发展现状	5
<br>
  <br>
<span style="margin-left:25px"></span> 1.2 本文的主要工作	5
<br>
  <br>
<span style="margin-left:25px"></span> 2 Web容器的研究	7
<br>
  <br>
<span style="margin-left:25px"></span> 2.1 HTTP协议分析	7
<br>
  <br>
<span style="margin-left:25px"></span> 2.1.1 HTTP协议概述	7
<br>
  <br>
<span style="margin-left:25px"></span> 2.1.2 HTTP协议的发展	7
<br>
  <br>
<span style="margin-left:25px"></span> 2.1.3 HTTP协议的传输过程	8
<br>
  <br>
<span style="margin-left:25px"></span> 2.1.4 HTTP协议的主要内容	10
<br>
  <br>
<span style="margin-left:25px"></span> 2.2 Socket编程	14
<br>
  <br>
<span style="margin-left:25px"></span> 2.2.1 Socket概述	14
<br>
  <br>
<span style="margin-left:25px"></span> 2.2.2 Java Socket编程	15
<br>
  <br>
<span style="margin-left:25px"></span> 2.3 本章小结	16
<br>
  <br>
<span style="margin-left:25px"></span> 3 Web服务器的设计	18
<br>
  <br>
<span style="margin-left:25px"></span> 3.1 总体模块划分	18
<br>
  <br>
<span style="margin-left:25px"></span> 3.2 业务流程	19
<br>
  <br>
<span style="margin-left:25px"></span> 4 Web服务器的实现	22
<br>
  <br>
<span style="margin-left:25px"></span> 4.1 概述	22
<br>
  <br>
<span style="margin-left:25px"></span> 4.2 connector模块	23
<br>
  <br>
<span style="margin-left:25px"></span> 4.2.1 connector模块概述	23
<br>
  <br>
<span style="margin-left:25px"></span> 4.2.2 监听socket请求的实现	23
<br>
  <br>
<span style="margin-left:25px"></span> 4.2.3 解析request请求的实现	25
<br>
  <br>
<span style="margin-left:25px"></span> 4.2.4 编码response响应的实现	27
<br>
  <br>
<span style="margin-left:25px"></span> 4.3 container模块	28
<br>
  <br>
<span style="margin-left:25px"></span> 4.3.1 container模块概述	28
<br>
  <br>
<span style="margin-left:25px"></span> 4.3.2 功能链	28
<br>
  <br>
<span style="margin-left:25px"></span> 4.3.3 URL映射	29
<br>
  <br>
<span style="margin-left:25px"></span> 4.4 parse模块	30
<br>
  <br>
<span style="margin-left:25px"></span> 结论	33
<br>
  <br>
<span style="margin-left:25px"></span> 参考文献	34
<br>
  <br>
<span style="margin-left:25px"></span> 致谢	35
<br>
  <br>
<span style="margin-left:25px"></span> 引言（前言）
<br>
  <br>
<span style="margin-left:25px"></span> 随着web应用的兴起和移动设备的快速增长，互联网迎来了爆炸式的发展，这也让web系统承载了巨大的压力，但这也推动了web的发展，使得web技术得到了很好的发展，如今web已经成为了Internet最主要的信息传送媒介，而web的发展同时也带动了web服务器的发展以适应日益增多的访问量以及各种需求。
<br>
  <br>
<span style="margin-left:25px"></span> Web服务器主要解决的是各种平台的计算机之间的信息交互。它主要采用的是传输层的TCP/IP协议来交换报文，http协议是位于传输层之上的应用层，http协议的内容就存放在TCP/IP协议中的报文中，本课题要研究的主要问题就是解析HTTP协议，正确加载静态与动态内容。
<br>
  <br>
<span style="margin-left:25px"></span> 1.	系统背景介绍
<br>
  <br>
<span style="margin-left:25px"></span> Web服务器就是可以为我们提供Web服务的主机，常用的web服务是http，我们在浏览器中键入URL地址，相对应的web服务器接收到一个HTTP请求，解析请求，并返回一个HTTP响应，返回的内容经过JavaScript的处理，以人类可读的方式显示在浏览器页面中。本课题做的就是做一个基于HTTP协议的实现Servlet规范的轻量级Web服务器。
<br>
  <br>
<span style="margin-left:25px"></span> 项目采用Java语言进行开发。Java语言从一开始就支持网络编程，并提供了大量类和接口可以用来处理各种网络协议，共享信息，并行计算，并且Java提供了完全意义的多线程支持，这些特点使得使用Java成为开发Web服务器的首选计算机语言，目前基于Java语言开发商用的Web服务器已经有一些了，如WebLogic，Tomcat等。
<br>
  <br>
<span style="margin-left:25px"></span> 1.1	Web服务器的发展现状
<br>
  <br>
<span style="margin-left:25px"></span> 随着互联网的快速发展，Web服务器也随之一起在数量和种类上得到了飞速发展，现如今，Web服务器主要分为WWW服务器，FTP服务器，邮件服务器，数据库服务器，代理服务器，域名服务器等等......在本文当中，我们主要介绍的是基于Java的Web容器，既能实现对静态资源的访问，当然主要是实现servlet规范从而可以实现响应动态内容。虽然Web容器可以单独运行，但是一般都是将其与apache等HTTP服务器一起搭配使用，因为apache等HTTP服务器加载静态内容的速度更加的快 ，由apache服务器来处理静态资源，而将动态响应交给Web容器来处理。
<br>
  <br>
<span style="margin-left:25px"></span> 1.2	本文的主要工作
<br>
  <br>
<span style="margin-left:25px"></span> 从前文得知，当前有许多种类型的Web容器，Web服务器，它们适合运行在不同的操作系统，不同的Web服务器以及不同的Web容器上，如C＃开发的服务器端后台一般都是部署在Windows Server操作系统的IIS Web服务器上，当然现在微软出了.NET Core后，C＃开发的服务器端程序也可以部署在Linux上面了，而Java开发的服务器端程序主要部署在Linux上的apache服务器与tomcat容器中。
<br>
  <br>
<span style="margin-left:25px"></span> 本文主要是设计一个基于Java的Web服务器，实现这个服务器是为了给上层的应用系统提供一个合适便利的开发平台。因为涉及到在此平台上进行上层的应用开发，所以将其称之为上层应用开发。因此，本Web服务器需要解决四个问题：①将TCP协议的报文解析成HTTP协议的内容，上层应用不需要再面对解析HTTP协议②上层应用不需要考虑对网络输入输出进行编程，只需要对业务进行编程即好③线程调度问题，上层应用不需要管理多线程，交由此Web服务器来管理多线程④URL映射问题，由web容器来决定此URL交由上层应用的哪个方法运行。
<br>
  <br>
<span style="margin-left:25px"></span> 2	Web容器的研究
<br>
  <br>
<span style="margin-left:25px"></span> Web服务器，其实就是能够给人们提供HTTP服务的主机，当用户通过在浏览器上键入该Web服务器的主机地址或者ip地址来访问该Web服务器上的各种所需资源。那么究竟什么是Web呢？WEB你可以这样简单理解为你所看到的HTML页面就是WEB的数据元素,处理这些数据元素的应用软件就叫WEB服务器,如IIS、apache。 WEB服务器与客户端打交道，它主要处理的信息有：session、request、response、HTML、JavaScript、CSS等。而Web容器如tomcat，处理的是非常规性WEB页面（JSP文件），他动态生成WEB页面，生成的WEB页面再发送给客户端。Web服务器一般是普遍通用的，而Web容器一般是专用的，如Tomcat只能处理JAVA应用程序而不能处理ASPX或PHP。而Apache是一个Web服务器（HTTP服务器），后来连接Tomcat应用服务器来支持java。
<br>
  <br>
<span style="margin-left:25px"></span> 2.1	HTTP协议分析
<br>
  <br>
<span style="margin-left:25px"></span> 2.1.1	HTTP协议概述
<br>
  <br>
<span style="margin-left:25px"></span> 超文本传输协议（Hypertext Transfer Protocol，简称HTTP）是应用层协议，它是基于TCP/IP通信协议来传递数据的，自 1990 年起，HTTP 就已经被应用于 WWW 全球信息服务系统。HTTP 是一种请求/响应式的协议。一个客户机与服务器成功建立连接后，发送一个请求给服务器；然后等服务器接到请求后，给予相应的响应信息。
<br>
  <br>
<span style="margin-left:25px"></span> 2.1.2	HTTP协议的发展
<br>
  <br>
<span style="margin-left:25px"></span> HTTP 的第一版本 HTTP/0.9是一种比较简单的用于网络间原始数据传输的协议,功能确实极其简单，不涉及数据包的传输，默认使用80端口，只有一个GET请求方法，且服务器只能响应HTML格式的字符串，服务器响应后即关闭连接。
<br>
  <br>
<span style="margin-left:25px"></span> HTTP/1.0由 RFC 1945 定义 ，在原 HTTP/0.9 的基础上，引入了POST和HEAD命令，大大增强了网络交互功能，可以发送任何格式的内容，为互联网的大发展而奠定了基础；同时，除去数据部分，每次通信还要求包含头信息（HTTP header），来描述一些meta数据。新增功能还包括：状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。 HTTP/1.0版的主要缺点有，由于TCP的每次连接都需要客户端和服务端进行3次握手，但是连接成功后却只能发送一次请求，而后连接就断开了，假如需要多次请求，这样效率就很低。所以，为了解决多次请求效率低下的问题，有一个非标准的connection字段算是暂时解决了这个问题。Connection: keep-alive。这样我们可以复用TCP连接，直到客户端或者服务端主动关闭了连接。不过这不是标志字段，不同的实现可能行为不一致，所以是一种暂时的解决方案。
<br>
  <br>
<span style="margin-left:25px"></span> HTTP/1.1进一步完善了HTTP协议，一直到现在还在使用，是最受欢迎的版本。HTTP/1.1新增了许多特性。
<br>
  <br>
<span style="margin-left:25px"></span> 1）	持久连接
<br>
  <br>
<span style="margin-left:25px"></span> HTTP/1.1默认TCP连接不关闭，能够被多个请求复用，不用声明Connection: keep-alive。在最后一个请求时，客户端可以主动发送Connection: close，明确要求服务器关闭TCP连接，或者选择不发送，那么客户端和服务器发现对方一段时间没有活动，就会主动关闭连接。目前，针对同一个域名，大多数浏览器允许同时建立6个持久连接。
<br>
  <br>
<span style="margin-left:25px"></span> 2）	管道机制
<br>
  <br>
<span style="margin-left:25px"></span> HTTP/1.1引入了管道机制（pipelining），即在同一个TCP连接里面，客户端能够同时发送多个请求，这样只不过改进了客户端HTTP协议请求的效率，服务器依然按照请求的先后顺序来响应。
<br>
  <br>
<span style="margin-left:25px"></span> 3）	Content-Length
<br>
  <br>
<span style="margin-left:25px"></span> Content-Length字段显示本次响应的数据长度，如果数据被压缩，则是显示压缩后的长度。在Connection: keep-alive条件下，Content-Length是必须要有的；反之，和HTTP/1.0一样，Content-Length不是必须的。
<br>
  <br>
<span style="margin-left:25px"></span> 4）	分块传输编码
<br>
  <br>
<span style="margin-left:25px"></span> 使用Content-Lenght字段有一个前提条件，就是在服务器发送响应之前，必须要知道响应的数据长度。但是，对于一些耗时的动态操作来说，等到所有操作完成了，服务器才能发送数据，效率是不高的。因此，HTTP采用了“流模式（stream）”，即“分块传输编码”（chunked transfer encoding）方式，表明响应的数据长度不确定，这样就可以每产生一块数据，就发送一块数据，从而提高服务器的响应效率。
<br>
  <br>
<span style="margin-left:25px"></span> 5）	Transfer-Encoding: chunked
<br>
  <br>
<span style="margin-left:25px"></span> 这样，只要请求或响应的头部信息里有Transfer-Encoding字段，就表明响应是由数量未定的数据来组成。每个非空的数据块前面，都会有一个16进制的数值，来表示这个块的长度；最后一个是大小为0的块，表示本次响应数据已发送完了。
<br>
  <br>
<span style="margin-left:25px"></span> 2.1.3	HTTP协议的传输过程
<br>
  <br>
<span style="margin-left:25px"></span> HTTP协议是位于OSI网络模型中的应用层，它是基于TCP/IP协议作为底层传输的。客户端的浏览器先是发起socket套接字的请求与服务器建立连接，等TCP三次握手成功后，客户端与服务器就连接建立，客户端将HTTP协议的内容封装在TCP协议中的报文，由TCP协议来发送给HTTP请求消息，这时客户端也从自己的TCP中的报文中接受到HTTP响应。等到客户端或者服务器将HTTP协议的内容发送给TCP之后，HTTP协议就不去管这个内容是怎样去传输的，TCP提供了一个可靠的端到端的数据传输服务，这就说明了每一个由客户端发出去的HTTP协议的内容都能以相同的顺序到达服务器端，且是无损的到达。这就是OSI网络模型中的解耦合，HTTP协议只需要密切关注本协议是如何运行的，无须担心数据会丢失，也不必担心TCP如何将数据从错误的顺序，以及错误的数据中恢复出来，这些已经是位于应用层以下的协议要去处理的任务了。
<br>
  <br>
<span style="margin-left:25px"></span> 下面分析具体的HTTP消息传输过程。
<br>
  <br>
<span style="margin-left:25px"></span> 图 2 1 HTTP消息传输过程
<br>
  <br>
<span style="margin-left:25px"></span> 1）	建立TCP连接
<br>
  <br>
<span style="margin-left:25px"></span> TCP连接在计算机中是通过socket来封装的，建立socket连接要提供一个ip地址和目的主机的端口号，直到通过三次握手成功建立连接后，就可以开始在客户端和服务器端进行数据传输了。
<br>
  <br>
<span style="margin-left:25px"></span> 2）	HTTP请求消息
<br>
  <br>
<span style="margin-left:25px"></span> 客户端将HTTP协议的内容封装交给socket来发送，其本质是将HTTP协议的内容封装到TCP协议报文中然后发送。
<br>
  <br>
<span style="margin-left:25px"></span> 3）	HTTP响应消息
<br>
  <br>
<span style="margin-left:25px"></span> 服务器端从socket中接受到HTTP协议的内容，经过解析后，按照请求内容发送相对应的响应消息。
<br>
  <br>
<span style="margin-left:25px"></span> 4）	释放TCP连接
<br>
  <br>
<span style="margin-left:25px"></span> 客户端和服务器端双方都可以通过关闭socket来释放TCP连接，在HTTP/1.0中，当服务器端发送完客户端请求的文件后会主动的关闭socket连接，而在HTTP/1.1中，一般是保持长连接的，并不关闭socket连接。
<br>
  <br>
<span style="margin-left:25px"></span> 2.1.4	HTTP协议的主要内容
<br>
  <br>
<span style="margin-left:25px"></span> HTTP协议的主要内容是关于HTTP请求和响应的文本，请求的文本是客户端要求服务器端提供的服务的信息，响应的文本则是服务器端接收到请求后返回给客户端的消息。
<br>
  <br>
<span style="margin-left:25px"></span> 1）	客户端请求格式
<br>
  <br>
<span style="margin-left:25px"></span> a）	请求的消息格式
<br>
  <br>
<span style="margin-left:25px"></span> 客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）请求头部（header）、空行和请求数据四个部分组成。
<br>
  <br>
<span style="margin-left:25px"></span> 图 2 2 请求消息格式
<br>
  <br>
<span style="margin-left:25px"></span> Get请求例子，使用Postman code模式看到的request请求的文本：
<br>
  <br>
<span style="margin-left:25px"></span> 表 2 1 Get请求例子
<br>
  <br>
<span style="margin-left:25px"></span> GET http://download.microtool.de:80/somedata.exe
<br>
  <br>
<span style="margin-left:25px"></span> Host: download.microtool.de
<br>
  <br>
<span style="margin-left:25px"></span> Accept:*/*
<br>
  <br>
<span style="margin-left:25px"></span> Pragma: no-cache
<br>
  <br>
<span style="margin-left:25px"></span> Cache-Control: no-cache
<br>
  <br>
<span style="margin-left:25px"></span> Referer: http://download.microtool.de/
<br>
  <br>
<span style="margin-left:25px"></span> User-Agent:Mozilla/4.04[en]（Win95;I;Nav）
<br>
  <br>
<span style="margin-left:25px"></span> Range:bytes=554554-
<br>
  <br>
<span style="margin-left:25px"></span> Postman-Token: 26d138d4-6123-479e-0bb9-15d37a936dcd
<br>
  <br>
<span style="margin-left:25px"></span> b）	请求方法
<br>
  <br>
<span style="margin-left:25px"></span> 方法描述了对于资源所要做的操作。在HTTP/1.1中的请求的方法有:OPTIONS,GET,HEAD,PUT,POST,TRACE,DELETE，其中最常用的是GET,POST,PUT,DELETE，在RESTFUL规范中，RESTFUL是以资源为导向设计API的，GET表示获取资源，POST表示添加资源，PUT表示修改资源，DELETE表示删除资源。
<br>
  <br>
<span style="margin-left:25px"></span> 图 2 3 HTTP请求方法
<br>
  <br>
<span style="margin-left:25px"></span> c）	头部字段
<br>
  <br>
<span style="margin-left:25px"></span> 头部字段分为通用请求头，请求头和响应头，通用请求头就是既能用于请求，也能用于响应，是作为一个整体而不是与事务相关联的特定资源，并且请求头和响应头就是只有在请求和响应时可以带上。请求头允许客户端传递关于自身的信息和所希望的响应形式，响应头用来表示服务器和于传递自身信息的响应。
<br>
  <br>
<span style="margin-left:25px"></span> 常用的请求头如下表所示：
<br>
  <br>
<span style="margin-left:25px"></span> 表 2 2 常用的请求头
<br>
  <br>
<span style="margin-left:25px"></span> Header	解释	示例
<br>
  <br>
<span style="margin-left:25px"></span> Accept	指定客户端能够接收的内容类型	Accept: text/plain, text/html
<br>
  <br>
<span style="margin-left:25px"></span> Accept-Charset	浏览器可以接受的字符编码集。	Accept-Charset: iso-8859-5
<br>
  <br>
<span style="margin-left:25px"></span> Accept-Encoding	指定浏览器可以支持的web服务器返回内容压缩编码类型。	Accept-Encoding: compress, gzip
<br>
  <br>
<span style="margin-left:25px"></span> Accept-Language	浏览器可接受的语言	Accept-Language: en,zh
<br>
  <br>
<span style="margin-left:25px"></span> Cookie	HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。	Cookie: $Version=1; Skin=new;
<br>
  <br>
<span style="margin-left:25px"></span> Content-Type	请求的与实体对应的MIME信息	Content-Type: application/x-www-form-urlencoded
<br>
  <br>
<span style="margin-left:25px"></span> Host	指定请求的服务器的域名和端口号	Host: www.zcmhi.com
<br>
  <br>
<span style="margin-left:25px"></span> 1）	服务器端响应
<br>
  <br>
<span style="margin-left:25px"></span> a）	响应的消息格式
<br>
  <br>
<span style="margin-left:25px"></span> 图 2 4 响应消息格式
<br>
  <br>
<span style="margin-left:25px"></span> 服务器端响应例子：
<br>
  <br>
<span style="margin-left:25px"></span> 表 2 3 服务器端响应例子
<br>
  <br>
<span style="margin-left:25px"></span> HTTP/1.1 200 OK
<br>
  <br>
<span style="margin-left:25px"></span> Date: Mon, 27 Jul 2009 12:28:53 GMT
<br>
  <br>
<span style="margin-left:25px"></span> Server: Apache01
<br>
  <br>
<span style="margin-left:25px"></span> Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
<br>
  <br>
<span style="margin-left:25px"></span> ETag: “34aa387-d-1568eb00“
<br>
  <br>
<span style="margin-left:25px"></span> Accept-Ranges: bytes
<br>
  <br>
<span style="margin-left:25px"></span> Content-Length: 51
<br>
  <br>
<span style="margin-left:25px"></span> Vary: Accept-Encoding
<br>
  <br>
<span style="margin-left:25px"></span> Content-Type: text/plain
<br>
  <br>
<span style="margin-left:25px"></span> Hello World! My payload includes a trailing CRLF.
<br>
  <br>
<span style="margin-left:25px"></span> b）	响应头
<br>
  <br>
<span style="margin-left:25px"></span> 常用的响应头如下表所示：
<br>
  <br>
<span style="margin-left:25px"></span> 表 2 4 常用的响应头
<br>
  <br>
<span style="margin-left:25px"></span> Header	解释	示例
<br>
  <br>
<span style="margin-left:25px"></span> Content-Encoding	web服务器支持的返回内容压缩编码类型。	Content-Encoding: gzip
<br>
  <br>
<span style="margin-left:25px"></span> Content-Language	响应体的语言	Content-Language: en,zh
<br>
  <br>
<span style="margin-left:25px"></span> Content-Length	响应体的长度	Content-Length: 348
<br>
  <br>
<span style="margin-left:25px"></span> Content-Location	请求资源可替代的备用的另一地址	Content-Location: /index.htm
<br>
  <br>
<span style="margin-left:25px"></span> Content-Type	返回内容的MIME类型	Content-Type: text/html; charset=utf-8
<br>
  <br>
<span style="margin-left:25px"></span> Last-Modified	请求资源的最后修改时间	Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT
<br>
  <br>
<span style="margin-left:25px"></span> Server	web服务器软件名称	Server: Apache/1.3.27 （Unix） （Red-Hat/Linux）
<br>
  <br>
<span style="margin-left:25px"></span> Set-Cookie	设置Http Cookie	Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1
<br>
  <br>
<span style="margin-left:25px"></span> 2.2	Socket编程
<br>
  <br>
<span style="margin-left:25px"></span> 2.2.1	Socket概述
<br>
  <br>
<span style="margin-left:25px"></span> 要了解socket，首先需要知道socket是对TCP/IP的封装，那么什么是TCP哪。TCP是Tranfer Control Protocol的 简称，是一种面向连接的保证可靠传输的协议。通过TCP协议传输，得到的是一个顺序的无差错的数据流。发送方和接收方的成对的两个socket之间必须建 立连接，以便在TCP协议的基础上进行通信，当一个socket（通常都是server socket）等待建立连接时，另一个socket可以要求进行连接，一旦这两个socket连接起来，它们就可以进行双向数据传输，双方都可以进行发送 或接收操作。
<br>
  <br>
<span style="margin-left:25px"></span> 2.2.2	Java Socket编程
<br>
  <br>
<span style="margin-left:25px"></span> Socket编程分为服务器端socket编程和客户端socket编程。下面分别介绍两种socket编程的步骤。
<br>
  <br>
<span style="margin-left:25px"></span> 1）	服务器端socket编程
<br>
  <br>
<span style="margin-left:25px"></span> a）	服务器端的socket首先需要绑定在本地的某个IP和端口上。在Java中默认为0.0.0.0，在服务器中0.0.0.0表示本机上所有的IPv4地址，因为服务器可能会有多个IP地址，比如绑定在127.0.0.1就表示这个Socket只能接受局域网内的socket连接。具体代码如下,表示绑定在本机IP为0.0.0.0的80端口上，80也是HTTP的默认端口号。
<br>
  <br>
<span style="margin-left:25px"></span> 表 2 5 服务器端绑定端口
<br>
  <br>
<span style="margin-left:25px"></span> ServerSocket serverSocket=new ServerSocket（80）
<br>
  <br>
<span style="margin-left:25px"></span> b）	将socket设置到监听模式等待客户端连接。这个accept（）方法是阻塞的，当有连接建立时，将返回一个socket用来和客户端进行交互。代码如下：
<br>
  <br>
<span style="margin-left:25px"></span> 表 2 6 等待连接
<br>
  <br>
<span style="margin-left:25px"></span> socket=serverSocket.accept（）
<br>
  <br>
<span style="margin-left:25px"></span> c）	使用连接建立后返回的socket与客户端进行通信。TCP是可以进行全双工通信的，所以通过socket变量，我们可以拿到输入流和输出流，输入流就是客户端发送给服务器端的信息，输出流就是服务器端想要返回给客户端的信息。代码如下:
<br>
  <br>
<span style="margin-left:25px"></span> 表 2 7 socket读写
<br>
  <br>
<span style="margin-left:25px"></span> InputStream is=socket.getInputStream（）;
<br>
  <br>
<span style="margin-left:25px"></span> BufferedInputstream bis=new BufferedInputstream（is）;
<br>
  <br>
<span style="margin-left:25px"></span> String content=bis.readLine（）;
<br>
  <br>
<span style="margin-left:25px"></span> OutputStream os=socket.getOutpuStream（）;
<br>
  <br>
<span style="margin-left:25px"></span> BufferedOutputStream bos=new BufferedOutputStream（os）;
<br>
  <br>
<span style="margin-left:25px"></span> String outputContent=”hello world”;
<br>
  <br>
<span style="margin-left:25px"></span> bos.write（bos） ;
<br>
  <br>
<span style="margin-left:25px"></span> d）	关闭连接。当客户端和服务器端的通信结束之后，需要释放连接。因为我们将socket的输入流和输出流用缓冲流包装了，所以关闭包装后的输入流和输出流也就是关闭socket自身的输入流和输出流，最后再关闭socket自身。代码如下:
<br>
  <br>
<span style="margin-left:25px"></span> 表 2 8 关闭socket
<br>
  <br>
<span style="margin-left:25px"></span> bis.close（）;
<br>
  <br>
<span style="margin-left:25px"></span> bos.close（）;
<br>
  <br>
<span style="margin-left:25px"></span> socket.close（）
<br>
  <br>
<span style="margin-left:25px"></span> 2）	客户端socket编程
<br>
  <br>
<span style="margin-left:25px"></span> a）	客户端首先需要新建Socket，并输入需要连接的服务器的IP地址和需要访问的端口号，下图表示与IP为1.1.1.1的主机在80端口号上建立连接。
<br>
  <br>
<span style="margin-left:25px"></span> 表 2 9 新建socket连接
<br>
  <br>
<span style="margin-left:25px"></span> Socket socket = new Socket（‘1.1.1.1’,80）
<br>
  <br>
<span style="margin-left:25px"></span> b）	使用连接建立后的socket与服务器端进行通信。Java的socket是自动进行连接的，不需要函数调用。
<br>
  <br>
<span style="margin-left:25px"></span> 表 2 10 socket读写
<br>
  <br>
<span style="margin-left:25px"></span> InputStream is=socket.getInputStream（）;
<br>
  <br>
<span style="margin-left:25px"></span> BufferedInputstream bis=new BufferedInputstream（is）;
<br>
  <br>
<span style="margin-left:25px"></span> String content=bis.readLine（）;
<br>
  <br>
<span style="margin-left:25px"></span> OutputStream os=socket.getOutpuStream（）;
<br>
  <br>
<span style="margin-left:25px"></span> BufferedOutputStream bos=new BufferedOutputStream（os）;
<br>
  <br>
<span style="margin-left:25px"></span> String outputContent=”hello world”;
<br>
  <br>
<span style="margin-left:25px"></span> bos.write（bos） ;
<br>
  <br>
<span style="margin-left:25px"></span> c）	关闭连接。当客户端和服务器端的通信结束之后，需要释放连接。因为我们将socket的输入流和输出流用缓冲流包装了，所以关闭包装后的输入流和输出流也就是关闭socket自身的输入流和输出流，最后再关闭socket自身。代码如下:
<br>
  <br>
<span style="margin-left:25px"></span> 表 2 11 关闭socket
<br>
  <br>
<span style="margin-left:25px"></span> bis.close（）;
<br>
  <br>
<span style="margin-left:25px"></span> bos.close（）;
<br>
  <br>
<span style="margin-left:25px"></span> socket.close（）
<br>
  <br>
<span style="margin-left:25px"></span> 2.3	本章小结
<br>
  <br>
<span style="margin-left:25px"></span> Web使用的主要是HTTP协议，在这一章中对HTTP进行了详尽的介绍，包括HTTP的请求格式，响应格式，请求方法，请求头以及传输过程等。
<br>
  <br>
<span style="margin-left:25px"></span> 本章之后介绍了Java下的Socket编程，服务器socket编程和客户端socket编程并没有太多区别，唯一的区别是服务器端最初需要一个ServerSocket来监听在绑定的IP和端口下有没有新新连接，当获得返回的socket后与客户端的编程就并无区别了。
<br>
  <br>
<span style="margin-left:25px"></span> 3	Web服务器的设计
<br>
  <br>
<span style="margin-left:25px"></span> 3.1	总体模块划分
<br>
  <br>
<span style="margin-left:25px"></span> 将整个服务器分为几个模块来分别编写，各个模块负责不同的功能，模块通过接口来调用其他模块，实现了解耦合。总体模块结构如图所示。
<br>
  <br>
<span style="margin-left:25px"></span> 图 3 1 总体模块划分
<br>
  <br>
<span style="margin-left:25px"></span> 下面将分别简单的介绍各个模块的功能。
<br>
  <br>
<span style="margin-left:25px"></span> 1）	Socket连接调度模块：Socket连接调度模块是提供对Socket的接受连接以及将socket封装在一个任务中将其交给线程池来处理。
<br>
  <br>
<span style="margin-left:25px"></span> 2）	HTTP解析模块：HTTP解析模块中可以分为两个子模块，分别是对HTTP请求解码模块以及对HTTP响应编码模块，如下图所示。
<br>
  <br>
<span style="margin-left:25px"></span> 图 3 2 HTTP解析模块划分
<br>
  <br>
<span style="margin-left:25px"></span> 3）	请求响应模块：请求响应模块主要处理的是socket的输入输出，以及数据的缓存.
<br>
  <br>
<span style="margin-left:25px"></span> 4）	Servlet调度模块：当获得解析的URL时候，由Servlet调度模块来决定应该使用哪个Servlet进行响应.
<br>
  <br>
<span style="margin-left:25px"></span> 5）	Filter调度模块：当获得解析的URL时候，由Filter调度模块来决定使用哪些个Filter来进行过滤
<br>
  <br>
<span style="margin-left:25px"></span> 6）	配置解析加载模块：Web服务器是采用外置xml文件来设置参数，如项目需要绑定的端口，Servlet需要映射的URL，打印日志的级别，项目的名称等。
<br>
  <br>
<span style="margin-left:25px"></span> 3.2	业务流程
<br>
  <br>
<span style="margin-left:25px"></span> 下面我将详细的介绍Web服务器的运行流程。
<br>
  <br>
<span style="margin-left:25px"></span> 1）	当Web服务器启动的时候首先加载xml配置文件进行配置
<br>
  <br>
<span style="margin-left:25px"></span> 2）	创建服务器套接字，并绑定端口，然后监听这个端口
<br>
  <br>
<span style="margin-left:25px"></span> 3）	Connector连接器负责接受接受客户端连接，初始化一个任务交给线程池，任务中包含解析HTTP请求，并构造请求和响应对象以供后续对象调用
<br>
  <br>
<span style="margin-left:25px"></span> 4）	将请求和响应对象交给container来调用，container检索请求对象的URL是否是servlet，若是，则加载servlet到内存中，执行该servlet相关方法，若不是，则加载相对应静态文件，若没有相对应的静态文件，则加载一个错误页面内容到响应对象中
<br>
  <br>
<span style="margin-left:25px"></span> 5）	将响应对象中的内容写入socket中
<br>
  <br>
<span style="margin-left:25px"></span> 6）	清除HTTP请求和响应对象
<br>
  <br>
<span style="margin-left:25px"></span> 7）	断开socket连接，一次请求结束
<br>
  <br>
<span style="margin-left:25px"></span> 这就是Web服务器运行的详细流程，同时我也画了具体的流程图如下所示。
<br>
  <br>
<span style="margin-left:25px"></span> 图 3 3 Web服务器流程
<br>
  <br>
<span style="margin-left:25px"></span> 4	Web服务器的实现
<br>
  <br>
<span style="margin-left:25px"></span> 4.1	概述
<br>
  <br>
<span style="margin-left:25px"></span> 本Web服务器是面向接口编程的，这样当有一个类B需要用到类A的时候，就不用需要A的实现类，只需要持有A的接口即可，不必关心实现类具体是哪个，达到了类之间的解耦合。为这个Web服务器，我设计了如下16个接口。
<br>
  <br>
<span style="margin-left:25px"></span> 下面我将分别介绍这16个接口的用途。
<br>
  <br>
<span style="margin-left:25px"></span> 1）	Chain,Valve,ValveSupport接口：这三个接口放在一起讲，是因为它们用来配合完成同一件事情。设计这三个接口中使用了责任链设计模式。Valve接口是用来定义一个在每次调用servlet方法前的方法，Chain接口是功能链，通过Chain将所有的Valve串联在一起，ValveSupport是一个支撑类，用来给Chain提供帮助。
<br>
  <br>
<span style="margin-left:25px"></span> 2）	Connector接口：connector接口主要完成的接受socket请求，然后转交给container进行处理。
<br>
  <br>
<span style="margin-left:25px"></span> 3）	Contained接口：contained接口用来指示实现它的接口持有哪个container容器的变量。
<br>
  <br>
<span style="margin-left:25px"></span> 4）	Container接口：container接口的实现类有ContextContainer和ServletContainer分别表示Web容器上下文以及单个servlet的容器。
<br>
  <br>
<span style="margin-left:25px"></span> 5）	ContextContainer接口：ContextContainer接口继承了Container接口，表示的是此Web容器的上下文。
<br>
  <br>
<span style="margin-left:25px"></span> 6）	HttpRequest，HttpResponse接口：这两个接口分别是HTTP请求和响应的接口，同时也继承了servlet规范的request,response接口
<br>
  <br>
<span style="margin-left:25px"></span> 7）	LifeCycleListener,LifeCycleSubject接口：这两个接口的设计使用了观察者模式，主要作用是实现模块间的关联启动。
<br>
  <br>
<span style="margin-left:25px"></span> 8）	Loader接口：Loader接口主要是实现安全加载servlet到容器中。
<br>
  <br>
<span style="margin-left:25px"></span> 9）	Mapper接口：Mapper接口的主要功能是实现URL到servletClass的映射。
<br>
  <br>
<span style="margin-left:25px"></span> 10）	Request，Response接口：这两个接口继承了servlet规范中的request,response接口，是这个Web容器中请求和响应的基类接口。
<br>
  <br>
<span style="margin-left:25px"></span> 4.2	connector模块
<br>
  <br>
<span style="margin-left:25px"></span> 4.2.1	connector模块概述
<br>
  <br>
<span style="margin-left:25px"></span> 此模块中的HttpRequestImpl,HttpResponseImpl都是请求和响应接口的具体实现，RequestStream,ResponseStream都是对socket的输入和输出流的缓冲流，同时加上一些功能。下面看这个模块下的所有的类的组成。
<br>
  <br>
<span style="margin-left:25px"></span> 图 4 1 connector模块中的类
<br>
  <br>
<span style="margin-left:25px"></span> 4.2.2	监听socket请求的实现
<br>
  <br>
<span style="margin-left:25px"></span> JerryConnector这个类是这个包的主类，由它来负责调用其他类。下面请看这个类的主方法，如下表所示
<br>
  <br>
<span style="margin-left:25px"></span> 表 4 1 监听socket请求的实现
<br>
  <br>
<span style="margin-left:25px"></span> public void run（）
<br>
  <br>
<span style="margin-left:25px"></span> {
<br>
  <br>
<span style="margin-left:25px"></span> while（start）
<br>
  <br>
<span style="margin-left:25px"></span> {
<br>
  <br>
<span style="margin-left:25px"></span> Socket socket=null;
<br>
  <br>
<span style="margin-left:25px"></span> try {
<br>
  <br>
<span style="margin-left:25px"></span> socket=serverSocket.accept（）;
<br>
  <br>
<span style="margin-left:25px"></span> if（timeOut＞0）
<br>
  <br>
<span style="margin-left:25px"></span> socket.setSoTimeout（timeOut）;
<br>
  <br>
<span style="margin-left:25px"></span> socket.setTcpNoDelay（true）;
<br>
  <br>
<span style="margin-left:25px"></span> HttpProcess process=new HttpProcess（socket,container）;
<br>
  <br>
<span style="margin-left:25px"></span> executorService.submit（process）;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> catch （IOException e） {
<br>
  <br>
<span style="margin-left:25px"></span> e.printStackTrace（）;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> finally {
<br>
  <br>
<span style="margin-left:25px"></span> if（socket!=null）
<br>
  <br>
<span style="margin-left:25px"></span> {
<br>
  <br>
<span style="margin-left:25px"></span> try {
<br>
  <br>
<span style="margin-left:25px"></span> socket.close（）;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> catch （IOException e） {
<br>
  <br>
<span style="margin-left:25px"></span> e.printStackTrace（）;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> if（serverSocket!=null）
<br>
  <br>
<span style="margin-left:25px"></span> {
<br>
  <br>
<span style="margin-left:25px"></span> try {
<br>
  <br>
<span style="margin-left:25px"></span> serverSocket.close（）;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> catch （IOException e） {
<br>
  <br>
<span style="margin-left:25px"></span> e.printStackTrace（）;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> 这个方法主要完成的是等待客户端socket的连接，当有连接之后，为这个连接设置一个超时自动关闭连接的时间，将这个socket包装进一个HttpProcess类，然后交给线程池来处理这个HttpProcess类，这样，这个服务器就可以以非阻塞的方式继续运行下去，当同时有多个连接进来时，也不会阻塞。同时，线程池也是一种高效的方式来利用线程，降低了每次创建新线程初始化线程上下文的时间，使得可以同时有更多的连接进来。
<br>
  <br>
<span style="margin-left:25px"></span> 4.2.3	解析request请求的实现
<br>
  <br>
<span style="margin-left:25px"></span> 解析HTTP协议的内容放在HttpProcess中进行的。我们知道，HTTP的请求中，第一行是请求行，第二行开始一直到空白行之前都是请求头，下面总览一下解析request请求代码。
<br>
  <br>
<span style="margin-left:25px"></span> 表 4 2 解析request请求的总体设计
<br>
  <br>
<span style="margin-left:25px"></span> void parseRequest（） throws IOException
<br>
  <br>
<span style="margin-left:25px"></span> {
<br>
  <br>
<span style="margin-left:25px"></span> parseRequestLine（）;
<br>
  <br>
<span style="margin-left:25px"></span> parseHeader（）;
<br>
  <br>
<span style="margin-left:25px"></span> setHeaderAttribute（）;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> 首先先是解析请求行，然后是解析请求头，最后是将请求行，请求头里解析出来的相关数据赋值到request请求中，以便后续使用，这里注意到我抛出了一个异常，假如请求解析失败则返回一个错误，记录到日志中，解析失败有可能是因为网络问题以及有人发送了错误的HTTP协议的文本请求到服务器。接下来，我们详细看下解析请求行和请求头的代码。
<br>
  <br>
<span style="margin-left:25px"></span> 我们来看解析请求行的代码
<br>
  <br>
<span style="margin-left:25px"></span> 表 4 3 解析请求行
<br>
  <br>
<span style="margin-left:25px"></span> void parseRequestLine（） throws IOException
<br>
  <br>
<span style="margin-left:25px"></span> {
<br>
  <br>
<span style="margin-left:25px"></span> String str=readLine（）;
<br>
  <br>
<span style="margin-left:25px"></span> Pattern pattern=patternFactory.getRequestLinePattern（）;
<br>
  <br>
<span style="margin-left:25px"></span> Matcher matcher= pattern.matcher（str）;
<br>
  <br>
<span style="margin-left:25px"></span> int condition=0;
<br>
  <br>
<span style="margin-left:25px"></span> while （matcher.find（））
<br>
  <br>
<span style="margin-left:25px"></span> {
<br>
  <br>
<span style="margin-left:25px"></span> String arg= matcher.group（）;
<br>
  <br>
<span style="margin-left:25px"></span> switch （condition）
<br>
  <br>
<span style="margin-left:25px"></span> {
<br>
  <br>
<span style="margin-left:25px"></span> case 0:
<br>
  <br>
<span style="margin-left:25px"></span> httpRequest.setMethod（arg.toUpperCase（））;
<br>
  <br>
<span style="margin-left:25px"></span> break;
<br>
  <br>
<span style="margin-left:25px"></span> case 1:
<br>
  <br>
<span style="margin-left:25px"></span> if（arg.contains（“?“））
<br>
  <br>
<span style="margin-left:25px"></span> {
<br>
  <br>
<span style="margin-left:25px"></span> String queryString=arg.substring（arg.indexOf（‘?‘）+1）;
<br>
  <br>
<span style="margin-left:25px"></span> queryString=
<br>
  <br>
<span style="margin-left:25px"></span> URLDecoder.decode（queryString,httpRequest.getCharacterEncoding（））;
<br>
  <br>
<span style="margin-left:25px"></span> arg=arg.substring（0,arg.indexOf（‘?‘））;
<br>
  <br>
<span style="margin-left:25px"></span> httpRequest.setQueryString（queryString）;
<br>
  <br>
<span style="margin-left:25px"></span> Pattern parametersPattern=patternFactory.getParameterPattern（）;
<br>
  <br>
<span style="margin-left:25px"></span> Matcher parametersMatch= parametersPattern.matcher（queryString）;
<br>
  <br>
<span style="margin-left:25px"></span> while（parametersMatch.find（））
<br>
  <br>
<span style="margin-left:25px"></span> {
<br>
  <br>
<span style="margin-left:25px"></span> String key=parametersMatch.group（1）;
<br>
  <br>
<span style="margin-left:25px"></span> String value=parametersMatch.group（2）;
<br>
  <br>
<span style="margin-left:25px"></span> httpRequest.setParameter（key,value）;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> httpRequest.setRequestURI（arg）;
<br>
  <br>
<span style="margin-left:25px"></span> break;
<br>
  <br>
<span style="margin-left:25px"></span> case 2:
<br>
  <br>
<span style="margin-left:25px"></span> httpRequest.setProtocol（arg）;
<br>
  <br>
<span style="margin-left:25px"></span> break;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> condition++;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> 在解析请求行中，因为请求行是一种规范的文本，所以我使用了正则表达式来帮助解析，之后是解析请求头
<br>
  <br>
<span style="margin-left:25px"></span> 表 4 4 解析请求头
<br>
  <br>
<span style="margin-left:25px"></span> void parseHeader（） throws IOException
<br>
  <br>
<span style="margin-left:25px"></span> {
<br>
  <br>
<span style="margin-left:25px"></span> String str=““;
<br>
  <br>
<span style="margin-left:25px"></span> while （（str=readLine（））!=““）
<br>
  <br>
<span style="margin-left:25px"></span> {
<br>
  <br>
<span style="margin-left:25px"></span> //blank line
<br>
  <br>
<span style="margin-left:25px"></span> if（str==“-1“）
<br>
  <br>
<span style="margin-left:25px"></span> break;
<br>
  <br>
<span style="margin-left:25px"></span> Pattern headerPattern=patternFactory.getHeaderPattern（）;
<br>
  <br>
<span style="margin-left:25px"></span> Matcher headerMatcher=headerPattern.matcher（str）;
<br>
  <br>
<span style="margin-left:25px"></span> String header,value;
<br>
  <br>
<span style="margin-left:25px"></span> if（headerMatcher.find（））
<br>
  <br>
<span style="margin-left:25px"></span> {
<br>
  <br>
<span style="margin-left:25px"></span> header=headerMatcher.group（1）;
<br>
  <br>
<span style="margin-left:25px"></span> value=headerMatcher.group（2）;
<br>
  <br>
<span style="margin-left:25px"></span> httpRequest.setHeader（header,value）;
<br>
  <br>
<span style="margin-left:25px"></span> if（header.equals（“Cookie“））
<br>
  <br>
<span style="margin-left:25px"></span> {
<br>
  <br>
<span style="margin-left:25px"></span> Pattern cookiePattern=patternFactory.getCookiePattern（）;
<br>
  <br>
<span style="margin-left:25px"></span> Matcher cookieMatcher=cookiePattern.matcher（value）;
<br>
  <br>
<span style="margin-left:25px"></span> String cookieKey,cookieValue;
<br>
  <br>
<span style="margin-left:25px"></span> while（cookieMatcher.find（））
<br>
  <br>
<span style="margin-left:25px"></span> {
<br>
  <br>
<span style="margin-left:25px"></span> cookieKey=cookieMatcher.group（“name“）;
<br>
  <br>
<span style="margin-left:25px"></span> cookieValue=cookieMatcher.group（“value“）;
<br>
  <br>
<span style="margin-left:25px"></span> httpRequest.setCookie（cookieKey,cookieValue）;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> 4.2.4	编码response响应的实现
<br>
  <br>
<span style="margin-left:25px"></span> 在用户编写的servlet代码里，是不需要关心返回的响应中的那些HTTP状态码，响应头这些的，这些都是由Web服务器来完成的，用户编写的servlet响应的文本是写入到Web服务器的缓存中的，也即ResponseStream中，因为servlet获取到的outputStream早已不是socket的outputStream，而是被我们替换成ResponseStream了，当servlet写入完成调用outputStrean的close方法啊，或者第一次调用outputStream的flush方法的时候，都会触发response的编码，具体的代码是在ResponseStream里面，如下所示
<br>
  <br>
<span style="margin-left:25px"></span> 表 4 5 编码response响应
<br>
  <br>
<span style="margin-left:25px"></span> private void writeHeaders（）
<br>
  <br>
<span style="margin-left:25px"></span> {
<br>
  <br>
<span style="margin-left:25px"></span> HttpResponse httpResponse= （HttpResponse） response;
<br>
  <br>
<span style="margin-left:25px"></span> StringBuilder sb=new StringBuilder（““）;
<br>
  <br>
<span style="margin-left:25px"></span> int s=httpResponse.getStatus（）;
<br>
  <br>
<span style="margin-left:25px"></span> HttpStatus  status=HttpStatus.getHttpStatus（s）;
<br>
  <br>
<span style="margin-left:25px"></span> sb.append（“HTTP/1.1 “+status.getStatus（）+“ “+status.getName（）+“\r\n“）;
<br>
  <br>
<span style="margin-left:25px"></span> for （String headerName : httpResponse.getHeaderNames（）） {
<br>
  <br>
<span style="margin-left:25px"></span> String value=httpResponse.getHeader（headerName）;
<br>
  <br>
<span style="margin-left:25px"></span> sb.append（headerName+“: “+value+“\r\n“）;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> sb.append（“\r\n“）;
<br>
  <br>
<span style="margin-left:25px"></span> try {
<br>
  <br>
<span style="margin-left:25px"></span> socketOutputStream.write（sb.toString（）.getBytes（response.getCharacterEncoding（）））;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> catch （IOException e） {
<br>
  <br>
<span style="margin-left:25px"></span> e.printStackTrace（）;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> 4.3	container模块
<br>
  <br>
<span style="margin-left:25px"></span> 4.3.1	container模块概述
<br>
  <br>
<span style="margin-left:25px"></span> 如图是container模块中的具体代码。
<br>
  <br>
<span style="margin-left:25px"></span> 图 4 2 container模块中的类
<br>
  <br>
<span style="margin-left:25px"></span> container模块是Web容器中相当重要的一个模块，connector模块接受socket后，就是直接转交给container模块进行处理的。container模块主要包含四个类，其中ContextContainerImpl是Web容器的上下文，ServletContainerImpl是单个servlet的容器，通过调用它就能对servlet进行操作。ChainImpl是在执行servlet方法前调用的一系列可横向扩展的类，MapperImpl类主要功能是根据配置文件中的URL映射，依据当前请求的URL来找到进行响应的servlet。
<br>
  <br>
<span style="margin-left:25px"></span> 4.3.2	功能链
<br>
  <br>
<span style="margin-left:25px"></span> 这是我对ChainImpl的中文名称的翻译。这个类的执行顺序是在执行servlet前，对于这个类的设计采用了责任链的设计模式，使得横向添加Valve类不需要改变代码。
<br>
  <br>
<span style="margin-left:25px"></span> 表 4 6 Valve集合
<br>
  <br>
<span style="margin-left:25px"></span> private Valve basicValve;
<br>
  <br>
<span style="margin-left:25px"></span> private ArrayList＜Valve＞ valves=new ArrayList＜＞（）;
<br>
  <br>
<span style="margin-left:25px"></span> 这个类中有一个Valve的集合，Valve接口只有一个invoke方法，如下所示
<br>
  <br>
<span style="margin-left:25px"></span> 表 4 7 Valve接口方法
<br>
  <br>
<span style="margin-left:25px"></span> void invoke（HttpRequest httpRequest,HttpResponse httpResponse,ValveSupport valveSupport）;
<br>
  <br>
<span style="margin-left:25px"></span> 通过这个接口我们就可以对请求和响应接口进行一些修改，或者是在响应前打日志，当然最主要的还是Servlet规范中的Filter接口的执行，Servlet规范中Filter是在Servlet的方法执行前调用的，有了ChainImpl这个类后我们就可以将Filter接口也放在这里执行，同时使用这个Web服务器的人也可以通过自定义Valve类来丰富Web服务器的功能。
<br>
  <br>
<span style="margin-left:25px"></span> 4.3.3	URL映射
<br>
  <br>
<span style="margin-left:25px"></span> URL映射的过程是这样子的，在配置文件中的写法参考了tomcat的xml配置文件的样式。
<br>
  <br>
<span style="margin-left:25px"></span> 表 4 8 XML配置文件范例
<br>
  <br>
<span style="margin-left:25px"></span> ＜servlet＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜servlet-name＞FirstServlet＜/servlet-name＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜servlet-class＞Two＜/servlet-class＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜/servlet＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜servlet-mapping＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜servlet-name＞FirstServlet＜/servlet-name＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜url-pattern＞/*＜/url-pattern＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜/servlet-mapping＞
<br>
  <br>
<span style="margin-left:25px"></span> Servlet-class中的参数是实际servlet文件的名称，我们在Web容器中为它指定另外一个名称，这个名称就是servlet-name标签中的名称。servlet-mapping标签中包含了两个子标签，其中servlet-name就是容器中指代某个servlet的名称，url-pattern标签的内容表示某个URL.那么当我们的服务器在接受到一个请求后，它查找servlet的流程是这样的
<br>
  <br>
<span style="margin-left:25px"></span> 1）	根据URL查找对应的servlet-name
<br>
  <br>
<span style="margin-left:25px"></span> 2）	若找到相对应的servlet-name则找到相对应的servlet-class
<br>
  <br>
<span style="margin-left:25px"></span> 我们从xml解析出来的映射关系存储在ContextContainerImpl中
<br>
  <br>
<span style="margin-left:25px"></span> 表 4 9 contextContainerImpl中的映射关系
<br>
  <br>
<span style="margin-left:25px"></span> private HashMap＜String, String＞ patternMap = new HashMap＜＞（）;
<br>
  <br>
<span style="margin-left:25px"></span> 具体查找映射关系是通过Mapper接口的实现类MapperImpl，下面看下具体代码:
<br>
  <br>
<span style="margin-left:25px"></span> 表 4 10 查找映射请求关系
<br>
  <br>
<span style="margin-left:25px"></span> public Container map（HttpRequest request）
<br>
  <br>
<span style="margin-left:25px"></span> {
<br>
  <br>
<span style="margin-left:25px"></span> if （request.getServletContainer（） != null） return request.getServletContainer（）;
<br>
  <br>
<span style="margin-left:25px"></span> String contextPath = request.getContextPath（）;
<br>
  <br>
<span style="margin-left:25px"></span> String relativeURI = request.getRequestURI（）.substring（contextPath.length（）+1）;
<br>
  <br>
<span style="margin-left:25px"></span> ServletContainer servletContainer = null;
<br>
  <br>
<span style="margin-left:25px"></span> String name = null;
<br>
  <br>
<span style="margin-left:25px"></span> if （servletContainer == null） {
<br>
  <br>
<span style="margin-left:25px"></span> name = container.findServletContainerMapping（relativeURI）;
<br>
  <br>
<span style="margin-left:25px"></span> if （name != null） {
<br>
  <br>
<span style="margin-left:25px"></span> servletContainer = （ServletContainer） container.getChild（name）;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> if （servletContainer == null） {
<br>
  <br>
<span style="margin-left:25px"></span> while （true） {
<br>
  <br>
<span style="margin-left:25px"></span> name = container.findServletContainerMapping（relativeURI）;
<br>
  <br>
<span style="margin-left:25px"></span> if （name != null） {
<br>
  <br>
<span style="margin-left:25px"></span> servletContainer = （ServletContainer） container.getChild（name）;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> if （servletContainer != null） {
<br>
  <br>
<span style="margin-left:25px"></span> break;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> int index = relativeURI.lastIndexOf（‘/‘）;
<br>
  <br>
<span style="margin-left:25px"></span> if （index ＜ 0） break;
<br>
  <br>
<span style="margin-left:25px"></span> relativeURI = relativeURI.substring（0, index）;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> if （servletContainer == null） {
<br>
  <br>
<span style="margin-left:25px"></span> relativeURI = request.getRequestURI（）.substring（contextPath.length（）+1）;
<br>
  <br>
<span style="margin-left:25px"></span> List＜String＞ urlList=URLUtil.splitUrl（relativeURI）;
<br>
  <br>
<span style="margin-left:25px"></span> urlList.add（“/“）;
<br>
  <br>
<span style="margin-left:25px"></span> for（int i=0;i＜urlList.size（）;i++）
<br>
  <br>
<span style="margin-left:25px"></span> {
<br>
  <br>
<span style="margin-left:25px"></span> name = container.findServletContainerMapping（urlList.get（i））;
<br>
  <br>
<span style="margin-left:25px"></span> if （name != null） {
<br>
  <br>
<span style="margin-left:25px"></span> servletContainer = （ServletContainer） container.getChild（name）;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> if （servletContainer != null） {
<br>
  <br>
<span style="margin-left:25px"></span> break;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> return servletContainer;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> 4.4	parse模块
<br>
  <br>
<span style="margin-left:25px"></span> Parse模块的主要工作是解析xml配置文件，并赋值给相关类，配置文件的格式如下
<br>
  <br>
<span style="margin-left:25px"></span> 表 4 11 xml配置文件范例
<br>
  <br>
<span style="margin-left:25px"></span> ＜?xml version=“1.0“ encoding=“UTF-8“?＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜web-app＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜context name=“jerry“ port=“80“ debug=“info“＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜webroot＞/home/jmt/IdeaProjects/Jerry/webroot/＜/webroot＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜servlet＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜servlet-name＞FirstServlet＜/servlet-name＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜servlet-class＞Two＜/servlet-class＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜/servlet＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜servlet-mapping＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜servlet-name＞FirstServlet＜/servlet-name＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜url-pattern＞/*＜/url-pattern＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜/servlet-mapping＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜/context＞
<br>
  <br>
<span style="margin-left:25px"></span> ＜/web-app＞
<br>
  <br>
<span style="margin-left:25px"></span> 具体的主要解析代码如下
<br>
  <br>
<span style="margin-left:25px"></span> 表 4 12 具体解析代码
<br>
  <br>
<span style="margin-left:25px"></span> private static ContextBean parseContext（Node contextNode）
<br>
  <br>
<span style="margin-left:25px"></span> {
<br>
  <br>
<span style="margin-left:25px"></span> ContextBean contextBean = new ContextBean（）;
<br>
  <br>
<span style="margin-left:25px"></span> NamedNodeMap attributeMap = contextNode.getAttributes（）;
<br>
  <br>
<span style="margin-left:25px"></span> Node name = attributeMap.getNamedItem（“name“）;
<br>
  <br>
<span style="margin-left:25px"></span> contextBean.setName（name.getNodeValue（））;
<br>
  <br>
<span style="margin-left:25px"></span> Node port = attributeMap.getNamedItem（“port“）;
<br>
  <br>
<span style="margin-left:25px"></span> contextBean.setPort（Integer.parseInt（port.getNodeValue（）））;
<br>
  <br>
<span style="margin-left:25px"></span> Node debug = attributeMap.getNamedItem（“debug“）;
<br>
  <br>
<span style="margin-left:25px"></span> contextBean.setDebug（debug.getNodeValue（））;
<br>
  <br>
<span style="margin-left:25px"></span> NodeList childList = contextNode.getChildNodes（）;
<br>
  <br>
<span style="margin-left:25px"></span> for （int i = 0; i ＜ childList.getLength（）; i++） {
<br>
  <br>
<span style="margin-left:25px"></span> Node node = childList.item（i）;
<br>
  <br>
<span style="margin-left:25px"></span> if （node.getNodeName（） == “webroot“） {
<br>
  <br>
<span style="margin-left:25px"></span> contextBean.setWebroot（node.getTextContent（））;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> else if （node.getNodeName（） == “servlet“） {
<br>
  <br>
<span style="margin-left:25px"></span> NodeList servletNodeList = node.getChildNodes（）;
<br>
  <br>
<span style="margin-left:25px"></span> String servletName = servletNodeList.item（0）.getTextContent（）;
<br>
  <br>
<span style="margin-left:25px"></span> String servletClass = servletNodeList.item（1）.getTextContent（）;
<br>
  <br>
<span style="margin-left:25px"></span> contextBean.setServletNameClass（servletName, servletClass）;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> else if （node.getNodeName（） == “servlet-mapping“） {
<br>
  <br>
<span style="margin-left:25px"></span> NodeList servletNodeList = node.getChildNodes（）;
<br>
  <br>
<span style="margin-left:25px"></span> String servletName = servletNodeList.item（0）.getTextContent（）;
<br>
  <br>
<span style="margin-left:25px"></span> String servletUrl = servletNodeList.item（1）.getTextContent（）;
<br>
  <br>
<span style="margin-left:25px"></span> contextBean.setServletNameUrl（servletName, servletUrl）;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> return contextBean;
<br>
  <br>
<span style="margin-left:25px"></span> }
<br>
  <br>
<span style="margin-left:25px"></span> 结论
<br>
  <br>
<span style="margin-left:25px"></span> 使用者可以将servlet代码部署在这个Web服务器上，服务器可以对静态资源和动态资源进行很好的响应。这个系统最突出的地方就是使用了大量的设计模式使得系统有良好的解耦性和可扩展性，connector和container是解耦合的，我们可以通过更换connector或者container来实现一个更符合业务的Web服务器。也可以自定义Valve来增强这个Web服务器的功能。不足的地方在于这个Web服务器的连接是同步非阻塞的，势必会遇到C10k问题，希望以后可以改成异步非阻塞，采用Java NIO来重写connector。
<br>
  <br>
<span style="margin-left:25px"></span> 参考文献
<br>
  <br>
<span style="margin-left:25px"></span> [1]马毅. 轻量级Web服务器的实现与应用[D]. 西北大学, 2008
<br>
  <br>
<span style="margin-left:25px"></span> [2]宋立昊. 基于线程池的WEB服务器实现和监测[D]. 吉林大学, 2011
<br>
  <br>
<span style="margin-left:25px"></span> [3]刘穿时. 轻量级web服务器的设计与实现[D]. 华中科技大学, 2016
<br>
  <br>
<span style="margin-left:25px"></span> [4]柴快长. 轻量级web容器的设计[J]. 科学与财富, 2013（1）:132-132
<br>
  <br>
<span style="margin-left:25px"></span> [5]Budi Kurniawan, Paul Deck, 曹旭东. 深入剖析Tomcat[M]. 机械工业出版社, 2012
<br>
  <br>
<span style="margin-left:25px"></span> [6]陈涛, 任海兰. 基于Linux的多线程池并发Web服务器设计[J]. 电子设计工程, 2015（11）:167-169
<br>
  <br>
<span style="margin-left:25px"></span> [7]兰红, 柳显涛, 李文琼. 基于Linux的预线程化并发Web服务器设计[J]. 江西理工大学学报, 2012, 33（1）:63-67
<br>
  <br>
<span style="margin-left:25px"></span> [8]上野宣. 图解 HTTP. 于均良译. 北京: 人民邮电出版社, 2014: 2-3
<br>
  <br>
<span style="margin-left:25px"></span> [9]沙洛韦. 设计模式精解[M]. 清华大学出版社, 2004
<br>
  <br>
<span style="margin-left:25px"></span> [10]VenkatSubramaniam, 苏帕拉马尼亚姆, 薛笛. Java虚拟机并发编程[M]. 机械工业出版社, 2013
<br>
  <br>
<span style="margin-left:25px"></span> [11]盖茨, 童云兰. Java并发编程实战[M]. 机械工业出版社, 2012
<br>
  <br>
<span style="margin-left:25px"></span> [12]杨小娇. 轻量级高并发Web服务器的研究与实现[D]. 南京邮电大学, 2014
<br>
  <br>
<span style="margin-left:25px"></span> [13]秦浏杰. 高并发Web系统的异步化研究[D]. 华北电力大学, 2015
<br>
  <br>
<span style="margin-left:25px"></span> [14]web服务器分类及发展趋势的研究[A].2010
<br>
  <br>
<span style="margin-left:25px"></span> “http://www.itxx.com.cn/Server/webserver/Server_44.html”
<br>
  <br>
<span style="margin-left:25px"></span> [15]Bielecki M, Hidders J, Paredaens J, et al. The Navigational Power of Web Browsers. Theory of Computing Systems, 2012, 50（2）: 213-240
<br>
  <br>
<span style="margin-left:25px"></span> [16]Snehi J, Dhir R. Web Client and Web Server approaches to Prevent XSS Attacks[J]. International Journal of Computers ＆ Technology, 2013, 4（2）:345-352
<br>
  <br>
<span style="margin-left:25px"></span> 致谢
<br>
  <br>
<span style="margin-left:25px"></span> 这次毕业论文的顺利完成，要感谢林春梅老师对我的精心指导。这使我能较好的完成这次的项目。如果没有老师的指导，我可能已经完全不知道如何去完成。感谢林春梅老师给我这么一个学习的机会。
<br>
</div>

<div style="margin-bottom:50px"></div>
</body>
</html>
